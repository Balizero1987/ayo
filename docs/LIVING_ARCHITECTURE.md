# LIVING ARCHITECTURE

*Auto-generated by The Scribe on 2025-12-17 12:23:50*

> **Note:** This document is automatically updated. Do not edit manually.

---

## Table of Contents

- [API Endpoints](#api-endpoints)
- [Modules](#modules)
- [Services](#services)
- [Agents](#agents)

---

## API Endpoints

### 

#### `GET /`

Root endpoint - health check

**File:** `app/routers/root_endpoints.py`

---

#### `GET /api/csrf-token`

Generate CSRF token and session ID for frontend security.
Returns token in both JSON body and response headers.

**File:** `app/routers/root_endpoints.py`

---

#### `GET /api/dashboard/stats`

Provide real-time stats for the Mission Control Dashboard.

Note: Currently returns mock data. In production, this would query
the database/orchestrator for real-time statistics.

**File:** `app/routers/root_endpoints.py`

---

#### `GET /api/intel/critical`

Get critical impact items

**File:** `app/routers/intel.py`

---

#### `GET /api/intel/stats/{collection}`

Get statistics for a specific intel collection

**File:** `app/routers/intel.py`

---

#### `GET /api/intel/trends`

Get trending topics and keywords

**File:** `app/routers/intel.py`

---

#### `POST /api/intel/search`

Search intel news with semantic search

**File:** `app/routers/intel.py`

---

#### `POST /api/intel/store`

Store intel news item in Qdrant

**File:** `app/routers/intel.py`

---

### Audio

#### `POST /audio/speech`

Generate speech from text (TTS). Returns audio/mpeg stream.

**File:** `app/routers/audio.py`

---

#### `POST /audio/transcribe`

Transcribe uploaded audio file to text.

**File:** `app/routers/audio.py`

---

### Collective Memory

#### `GET /api/collective-memory/facts`

Get all promoted collective facts.

Optional: filter by category.

**File:** `app/routers/collective_memory.py`

---

#### `GET /api/collective-memory/stats`

Get collective memory statistics.

**File:** `app/routers/collective_memory.py`

---

#### `POST /api/collective-memory/contribute`

Contribute a fact to collective memory.

When 3+ different users contribute/confirm the same fact,
it becomes "promoted" and is included in AI context for all users.

**File:** `app/routers/collective_memory.py`

---

#### `POST /api/collective-memory/refute`

Refute a collective memory fact.

Decreases confidence. If confidence drops below 0.2, fact is removed.

**File:** `app/routers/collective_memory.py`

---

### Episodic Memory

#### `DELETE /api/episodic-memory/events/{event_id}`

Delete an event from the user's timeline.

Users can only delete their own events.

**File:** `app/routers/episodic_memory.py`

---

#### `GET /api/episodic-memory/context`

Get a formatted context summary for AI prompts.

Returns recent events formatted as markdown for inclusion
in AI system prompts.

**File:** `app/routers/episodic_memory.py`

---

#### `GET /api/episodic-memory/stats`

Get user's episodic memory statistics.

Returns counts by event type and overall stats.

**File:** `app/routers/episodic_memory.py`

---

#### `GET /api/episodic-memory/timeline`

Get the user's event timeline.

Returns events in reverse chronological order (most recent first).
Optional filters:
- event_type: Filter by type (milestone, problem, etc.)
- emotion: Filter by emotional context
- start_date/end_date: Filter by date range
- limit: Maximum number of events (default 20)

**File:** `app/routers/episodic_memory.py`

---

#### `POST /api/episodic-memory/events`

Add an event to the user's episodic memory timeline.

Events track the user's journey through time:
- Milestones achieved
- Problems encountered
- Resolutions found
- Decisions made
- Meetings held
- Deadlines set

**File:** `app/routers/episodic_memory.py`

---

#### `POST /api/episodic-memory/extract`

Automatically extract an event from a message and save it.

Looks for temporal references like:
- "oggi", "today", "yesterday"
- "N giorni fa", "days ago"
- "last week", "settimana scorsa"
- Specific dates: DD/MM, DD/MM/YYYY

If no temporal reference is found, no event is created.

**File:** `app/routers/episodic_memory.py`

---

### Oracle INGEST

#### `GET /api/oracle/collections`

List all available collections

**Returns:**
- List of collection names
- Document counts for each collection

**File:** `app/routers/oracle_ingest.py`

---

#### `POST /api/oracle/ingest`

Bulk ingest documents into Qdrant collection

**Usage:**
```python
import requests

chunks = [
    {
        "content": "### PP-28-2025 - Pasal 1\n\nContent here...",
        "metadata": {
            "law_id": "PP-28-2025",
            "pasal": "1",
            "category": "business_licensing",
            "type": "legal_regulation"
        }
    }
]

response = requests.post(
    "https://nuzantara-rag.fly.dev/api/oracle/ingest",
    json={"collection": "legal_intelligence", "documents": chunks}
)
```

**Rate Limits:**
- Max 1000 documents per request
- Batch processing for large uploads

**Response Model:** `IngestResponse`

**File:** `app/routers/oracle_ingest.py`

---

### Oracle v5.3 - Ultra Hybrid

#### `GET /api/oracle/drive/test`

Test Google Drive integration

**File:** `app/routers/oracle_universal.py`

---

#### `GET /api/oracle/gemini/test`

Test Google Gemini integration

**File:** `app/routers/oracle_universal.py`

---

#### `GET /api/oracle/health`

Health check for Oracle v5.3 services

**File:** `app/routers/oracle_universal.py`

---

#### `GET /api/oracle/user/profile/{user_email}`

Get user profile with localization preferences

**File:** `app/routers/oracle_universal.py`

---

#### `POST /api/oracle/feedback`

Submit user feedback for continuous learning and system improvement

**File:** `app/routers/oracle_universal.py`

---

#### `POST /api/oracle/query`

Ultra Hybrid Oracle Query - v5.3 (Refactored)
Integrates Qdrant search, Google Drive, and Gemini reasoning via OracleService.

**Response Model:** `OracleQueryResponse`

**File:** `app/routers/oracle_universal.py`

---

### agentic-functions

#### `GET /api/agents/analytics/summary`

Get comprehensive analytics for all agentic functions

Performance: Cached for 3 minutes (reduces database load)

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/compliance/alerts`

Get upcoming compliance alerts

Args:
    client_id: Filter by client
    severity: Filter by severity
    auto_notify: Automatically send notifications for alerts

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/compliance/client/{client_id}`

Get all compliance items for a client

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/ingestion/status`

Get status of automatic ingestion service

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/journey/{journey_id}`

Get journey details and progress

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/journey/{journey_id}/next-steps`

Get next available steps in the journey

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/knowledge-graph/export`

Export knowledge graph in Neo4j-ready format

‚ö†Ô∏è PLACEHOLDER ENDPOINT: Service not implemented
Knowledge Graph builder exists but export functionality is not wired.

Formats:
- neo4j: Cypher queries for Neo4j
- json: JSON format
- graphml: GraphML format

**File:** `app/routers/agents.py`

---

#### `GET /api/agents/status`

Get status of all 10 agentic functions

Returns:
    Overall system status and capabilities

Performance: Cached for 5 minutes (90% faster on cache hit)

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/compliance/track`

‚ö†Ô∏è AGENT 2: Proactive Compliance Monitor

Track compliance deadlines and get automatic alerts (60/30/7 days before)

Supported types:
- visa_expiry: KITAS, KITAP, passport expiry
- tax_filing: SPT Tahunan, PPh, PPn deadlines
- license_renewal: IMTA, NIB, business permits
- regulatory_change: Law/regulation changes

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/ingestion/run`

ü§ñ AGENT 4: Auto Ingestion Orchestrator

‚ö†Ô∏è PLACEHOLDER ENDPOINT: Service exists but not wired into main_cloud.py
The AutoIngestionOrchestrator service is implemented but not initialized.

Automatically monitor and ingest updates from government sources

Sources:
- https://jdih.kemenkeu.go.id (Tax regulations)
- https://peraturan.bpk.go.id (Legal documents)
- https://jdih.kemendag.go.id (Trade regulations)
- https://ortax.org (Tax news)

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/journey/create`

üéØ AGENT 1: Client Journey Orchestrator

Create a new multi-step client journey with automatic progress tracking

Example journeys:
- pt_pma_setup: Complete PT PMA company setup (7 steps)
- kitas_application: KITAS visa application (5 steps)
- property_purchase: Property purchase process (6 steps)

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/journey/{journey_id}/step/{step_id}/complete`

Mark a journey step as completed

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/knowledge-graph/extract`

üß† AGENT 3: Knowledge Graph Builder

Extract entities and relationships from text to build knowledge graph.

Entities: Person, Organization, Location, Document, Concept
Relationships: WORKS_FOR, LOCATED_IN, REQUIRES, RELATED_TO, etc.

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/pricing/calculate`

üí∞ AGENT 6: Dynamic Pricing Service

Calculate pricing based on service type, complexity, and urgency

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/research/autonomous`

üî¨ AGENT 7: Autonomous Research Service

Self-directed research agent that iteratively explores Qdrant collections
to answer complex or ambiguous queries without human intervention.

Example: "How to open a crypto company in Indonesia?"
‚Üí Iteration 1: Search kbli_eye ‚Üí "crypto" not in KBLI
‚Üí Iteration 2: Expand to legal_updates ‚Üí finds OJK crypto regulation
‚Üí Iteration 3: Search tax_genius ‚Üí crypto tax treatment
‚Üí Synthesis: Comprehensive answer

Args:
    topic: Research topic/question
    depth: standard (3 iterations), deep (5 iterations)
    sources: Optional list of specific collections to search

**File:** `app/routers/agents.py`

---

#### `POST /api/agents/synthesis/cross-oracle`

üîç AGENT 5: Cross-Oracle Synthesis

Search across multiple Oracle collections and synthesize integrated recommendations.

Example: "I want to open a restaurant in Canggu"
‚Üí Queries: kbli_eye, legal_architect, tax_genius, visa_oracle, property_knowledge
‚Üí Synthesizes: Integrated plan with KBLI code, legal structure, tax obligations, etc.

**File:** `app/routers/agents.py`

---

### agentic-rag

#### `POST /api/agentic-rag/query`

Esegue una query usando il sistema Agentic RAG completo.

**Response Model:** `AgenticQueryResponse`

**File:** `app/routers/agentic_rag.py`

---

#### `POST /api/agentic-rag/stream`

Stream the Agentic RAG process (SSE).
Supports conversation history via:
1. Direct conversation_history from frontend (preferred - works even if DB is down)
2. conversation_id or session_id lookup from database (fallback)

**File:** `app/routers/agentic_rag.py`

---

### authentication

#### `GET /api/auth/check`

Check if current session is valid

**File:** `app/routers/auth.py`

---

#### `GET /api/auth/csrf-token`

Generate CSRF token and session ID for frontend security.
Returns token in both JSON body and response headers.

**File:** `app/routers/auth.py`

---

#### `GET /api/auth/profile`

Get current user profile

**Response Model:** `UserProfile`

**File:** `app/routers/auth.py`

---

#### `POST /api/auth/login`

User login with email and PIN

Returns JWT token and user profile on successful authentication.
Also sets httpOnly cookie with JWT token and CSRF cookie.

**Response Model:** `LoginResponse`

**File:** `app/routers/auth.py`

---

#### `POST /api/auth/logout`

Logout user and clear authentication cookies.

Note: JWT tokens are stateless, so we only clear cookies.
Client should also discard any stored tokens.

**File:** `app/routers/auth.py`

---

#### `POST /api/auth/refresh`

Refresh JWT access token

Generates a new access token for the authenticated user without requiring
re-authentication. The user must provide a valid current token.
Also updates the httpOnly cookie with the new token.

**Response Model:** `LoginResponse`

**File:** `app/routers/auth.py`

---

### autonomous-tier1

#### `GET /api/autonomous-agents/executions`

List recent agent executions

Args:
    limit: Maximum number of executions to return (default: 20)

Returns:
    List of recent executions

**File:** `app/routers/autonomous_agents.py`

---

#### `GET /api/autonomous-agents/executions/{execution_id}`

Get status of a specific agent execution

Args:
    execution_id: Execution ID returned by agent run endpoint

Returns:
    Execution details and result

**Response Model:** `AgentExecutionResponse`

**File:** `app/routers/autonomous_agents.py`

---

#### `GET /api/autonomous-agents/scheduler/status`

ü§ñ Get status of the Autonomous Scheduler and all registered tasks

Returns:
    Scheduler status with task details:
    - running: Whether scheduler is active
    - task_count: Number of registered tasks
    - tasks: Details of each task (intervals, run counts, errors)

**File:** `app/routers/autonomous_agents.py`

---

#### `GET /api/autonomous-agents/status`

Get status of all Tier 1 autonomous agents

Returns:
    Agent capabilities and recent executions

**File:** `app/routers/autonomous_agents.py`

---

#### `POST /api/autonomous-agents/client-value-predictor/run`

üí∞ Run Client LTV Predictor & Nurturing Agent

Scores all clients and sends personalized nurturing messages to:
- VIP clients (LTV > 80)
- High-risk clients (LTV < 30 and inactive > 30 days)

Returns:
    Execution status (agent runs in background)

**Response Model:** `AgentExecutionResponse`

**File:** `app/routers/autonomous_agents.py`

---

#### `POST /api/autonomous-agents/conversation-trainer/run`

ü§ñ Run Conversation Quality Trainer Agent

Analyzes high-rated conversations and generates prompt improvements

Args:
    days_back: Number of days to look back for conversations (default: 7)

Returns:
    Execution status (agent runs in background)

**Response Model:** `AgentExecutionResponse`

**File:** `app/routers/autonomous_agents.py`

---

#### `POST /api/autonomous-agents/knowledge-graph-builder/run`

üï∏Ô∏è Run Knowledge Graph Builder Agent

Extracts entities and relationships from conversations and builds knowledge graph

Args:
    days_back: Number of days to look back for conversations (default: 30)
    init_schema: Initialize database schema (default: False)

Returns:
    Execution status (agent runs in background)

**Response Model:** `AgentExecutionResponse`

**File:** `app/routers/autonomous_agents.py`

---

#### `POST /api/autonomous-agents/scheduler/task/{task_name}/disable`

‚è∏Ô∏è Disable a scheduled task

Args:
    task_name: Name of the task to disable

**File:** `app/routers/autonomous_agents.py`

---

#### `POST /api/autonomous-agents/scheduler/task/{task_name}/enable`

‚úÖ Enable a scheduled task

Args:
    task_name: Name of the task to enable

**File:** `app/routers/autonomous_agents.py`

---

### conversations

#### `DELETE /api/bali-zero/conversations/clear`

Clear conversation history for the authenticated user

SECURITY: User identity is extracted from JWT token.

Query params:
- session_id: Optional session filter (if omitted, clears ALL conversations for user)

**File:** `app/routers/conversations.py`

---

#### `DELETE /api/bali-zero/conversations/{conversation_id}`

Delete a single conversation by ID

SECURITY: Only deletes conversation if it belongs to authenticated user.

**File:** `app/routers/conversations.py`

---

#### `GET /api/bali-zero/conversations/history`

Get conversation history for the authenticated user

SECURITY: User identity is extracted from JWT token.

Query params:
- limit: Max number of messages to return (default: 20)
- session_id: Optional session filter

**File:** `app/routers/conversations.py`

---

#### `GET /api/bali-zero/conversations/list`

List all conversations for the authenticated user

SECURITY: User identity is extracted from JWT token.

Query params:
- limit: Max number of conversations to return (default: 20)
- offset: Offset for pagination (default: 0)

Returns list with title (first user message), preview, and message count.

**Response Model:** `ConversationListResponse`

**File:** `app/routers/conversations.py`

---

#### `GET /api/bali-zero/conversations/memory/context`

Get user memory context (profile facts, summary, counters)

SECURITY: User identity is extracted from JWT token.

Returns the user's stored memory facts and context that the AI uses
to personalize responses.

**Response Model:** `UserMemoryContextResponse`

**File:** `app/routers/conversations.py`

---

#### `GET /api/bali-zero/conversations/stats`

Get conversation statistics for the authenticated user

SECURITY: User identity is extracted from JWT token.

**File:** `app/routers/conversations.py`

---

#### `GET /api/bali-zero/conversations/{conversation_id}`

Get a single conversation by ID

SECURITY: Only returns conversation if it belongs to authenticated user.

**Response Model:** `SingleConversationResponse`

**File:** `app/routers/conversations.py`

---

#### `POST /api/bali-zero/conversations/save`

Save conversation messages to PostgreSQL
+ Auto-populate CRM with client/practice data

SECURITY: User identity is extracted from JWT token, not request body.

Body:
{
    "messages": [{"role": "user", "content": "..."}, ...],
    "session_id": "optional-session-id",
    "metadata": {"key": "value"}
}

Returns:
{
    "success": true,
    "conversation_id": 123,
    "messages_saved": 10,
    "user_email": "authenticated-user@example.com",
    "crm": {
        "processed": true,
        "client_id": 42,
        "client_created": false,
        "client_updated": true,
        "practice_id": 15,
        "practice_created": true,
        "interaction_id": 88
    }
}

**File:** `app/routers/conversations.py`

---

### crm-clients

#### `DELETE /api/crm/clients/{client_id}`

Delete a client (soft delete - marks as inactive)

This doesn't permanently delete the client, just marks them as inactive.
Use with caution as this will also affect related practices and interactions.

**File:** `app/routers/crm_clients.py`

---

#### `GET /api/crm/clients/`

List all clients with optional filtering

- **status**: Filter by client status
- **assigned_to**: Filter by assigned team member
- **search**: Search in name, email, phone fields
- **limit**: Max results (default: 50, max: 200)
- **offset**: For pagination

**File:** `app/routers/crm_clients.py`

---

#### `GET /api/crm/clients/by-email/{email}`

Get client by email address

**Response Model:** `ClientResponse`

**File:** `app/routers/crm_clients.py`

---

#### `GET /api/crm/clients/stats/overview`

Get overall client statistics

Returns counts by status, top assigned team members, etc.

Performance: Cached for 5 minutes to reduce database load.

**File:** `app/routers/crm_clients.py`

---

#### `GET /api/crm/clients/{client_id}`

Get client by ID

**Response Model:** `ClientResponse`

**File:** `app/routers/crm_clients.py`

---

#### `GET /api/crm/clients/{client_id}/summary`

Get comprehensive client summary including:
- Basic client info
- All practices (active + completed)
- Recent interactions
- Documents
- Upcoming renewals

**File:** `app/routers/crm_clients.py`

---

#### `PATCH /api/crm/clients/{client_id}`

Update client information

Only provided fields will be updated. Other fields remain unchanged.

**Response Model:** `ClientResponse`

**File:** `app/routers/crm_clients.py`

---

#### `POST /api/crm/clients/`

Create a new client

- **full_name**: Client's full name (required)
- **email**: Email address (optional but recommended)
- **phone**: Phone number
- **whatsapp**: WhatsApp number (can be same as phone)
- **nationality**: Client's nationality
- **passport_number**: Passport number
- **assigned_to**: Team member email to assign client to
- **tags**: Array of tags (e.g., ['vip', 'urgent'])

**Response Model:** `ClientResponse`

**File:** `app/routers/crm_clients.py`

---

### crm-interactions

#### `GET /api/crm/interactions/`

List interactions with optional filtering

**File:** `app/routers/crm_interactions.py`

---

#### `GET /api/crm/interactions/client/{client_id}/timeline`

Get complete interaction timeline for a client

Returns all interactions sorted by date (newest first)

**File:** `app/routers/crm_interactions.py`

---

#### `GET /api/crm/interactions/practice/{practice_id}/history`

Get all interactions related to a specific practice

Useful for tracking communication history for a KITAS, PT PMA, etc.

**File:** `app/routers/crm_interactions.py`

---

#### `GET /api/crm/interactions/stats/overview`

Get interaction statistics

- Total interactions
- By type (chat, email, call, etc.)
- By sentiment
- By team member

Performance: Cached for 5 minutes to reduce database load.

**File:** `app/routers/crm_interactions.py`

---

#### `GET /api/crm/interactions/{interaction_id}`

Get full interaction details by ID

**File:** `app/routers/crm_interactions.py`

---

#### `POST /api/crm/interactions/`

Log a new interaction

**Types:**
- chat: Web chat conversation
- email: Email exchange
- whatsapp: WhatsApp message
- call: Phone call
- meeting: In-person or video meeting
- note: Internal note/comment

**Channels:**
- web_chat: ZANTARA chat widget
- gmail: Gmail integration
- whatsapp: WhatsApp Business
- phone: Phone call
- in_person: Face-to-face meeting

**Response Model:** `InteractionResponse`

**File:** `app/routers/crm_interactions.py`

---

#### `POST /api/crm/interactions/from-conversation`

Auto-create interaction record from a chat conversation

This is called automatically when a chat session ends or at intervals

**File:** `app/routers/crm_interactions.py`

---

### crm-practices

#### `GET /api/crm/practices/`

List practices with optional filtering

Returns practices with client and practice type information joined

**File:** `app/routers/crm_practices.py`

---

#### `GET /api/crm/practices/active`

Get all active practices (in progress, not completed/cancelled)

Optionally filter by assigned team member

**File:** `app/routers/crm_practices.py`

---

#### `GET /api/crm/practices/renewals/upcoming`

Get practices with upcoming renewal dates

Default: next 90 days

**File:** `app/routers/crm_practices.py`

---

#### `GET /api/crm/practices/stats/overview`

Get overall practice statistics

- Counts by status
- Counts by practice type
- Revenue metrics

Performance: Cached for 5 minutes to reduce database load.

**File:** `app/routers/crm_practices.py`

---

#### `GET /api/crm/practices/{practice_id}`

Get practice details by ID with full client and type info

**File:** `app/routers/crm_practices.py`

---

#### `PATCH /api/crm/practices/{practice_id}`

Update practice information

Common status values:
- inquiry
- quotation_sent
- payment_pending
- in_progress
- waiting_documents
- submitted_to_gov
- approved
- completed
- cancelled

**File:** `app/routers/crm_practices.py`

---

#### `POST /api/crm/practices/`

Create a new practice for a client

- **client_id**: ID of the client
- **practice_type_code**: Practice type code (retrieved from database)
- **status**: Initial status (default: 'inquiry')
- **quoted_price**: Price quoted to client
- **assigned_to**: Team member email to handle this

**Response Model:** `PracticeResponse`

**File:** `app/routers/crm_practices.py`

---

#### `POST /api/crm/practices/{practice_id}/documents/add`

Add a document to a practice

- **document_name**: Name/type of document (e.g., "Passport Copy")
- **drive_file_id**: Google Drive file ID
- **uploaded_by**: Email of person uploading

**File:** `app/routers/crm_practices.py`

---

### crm-shared-memory

#### `GET /api/crm/shared-memory/client/{client_id}/full-context`

Get complete context for a client
Everything the AI needs to know about this client

Returns:
- Client info
- All practices (active + completed)
- Recent interactions (last 20)
- Upcoming renewals
- Action items

**File:** `app/routers/crm_shared_memory.py`

---

#### `GET /api/crm/shared-memory/search`

Natural language search across CRM data

Examples:
- "clients with KITAS expiring soon"
- "active practices for John Smith"
- "recent interactions with antonello@balizero.com"
- "urgent practices"
- "PT PMA practices in progress"

Returns relevant results from clients, practices, and interactions

**File:** `app/routers/crm_shared_memory.py`

---

#### `GET /api/crm/shared-memory/team-overview`

Get team-wide CRM overview

Perfect for dashboard or team queries like:
- "How many active practices do we have?"
- "What's our workload distribution?"
- "Recent activity summary"

Performance: Cached for 5 minutes to reduce database load.

**File:** `app/routers/crm_shared_memory.py`

---

#### `GET /api/crm/shared-memory/upcoming-renewals`

Get all practices with upcoming renewal dates

Default: next 90 days

Performance: Cached for 10 minutes to reduce database load.

**File:** `app/routers/crm_shared_memory.py`

---

### handlers

#### `GET /api/handlers/category/{category}`

Get all handlers in a specific category

**File:** `app/routers/handlers.py`

---

#### `GET /api/handlers/list`

Returns complete registry of all available handlers
This is the master catalog that ZANTARA uses to see all available tools

**File:** `app/routers/handlers.py`

---

#### `GET /api/handlers/search`

Search handlers by name, path, or description

**File:** `app/routers/handlers.py`

---

### health

#### `GET /health`

System health check - Non-blocking during startup.

Returns "initializing" immediately if service not ready.
Prevents container crashes during warmup by not creating heavy objects.

**Response Model:** `HealthResponse`

**File:** `app/routers/health.py`

---

#### `GET /health/`

System health check - Non-blocking during startup.

Returns "initializing" immediately if service not ready.
Prevents container crashes during warmup by not creating heavy objects.

**Response Model:** `HealthResponse`

**File:** `app/routers/health.py`

---

#### `GET /health/debug/config`

TEMPORARY: Debug endpoint to check loaded configuration.
Shows what API keys and config the backend actually loaded.

**File:** `app/routers/health.py`

---

#### `GET /health/detailed`

Detailed health check showing all service statuses.

Returns comprehensive information about each service for debugging
and monitoring purposes. Includes:
- Individual service status (healthy/degraded/unavailable)
- Error messages for failed services
- Database connectivity check
- Overall system health assessment

Returns:
    dict: Detailed health status with per-service breakdown

**File:** `app/routers/health.py`

---

#### `GET /health/live`

Kubernetes-style liveness probe.

Returns 200 if the application is running (even if not fully ready).
Used by orchestrators to determine if instance needs restart.

Returns:
    dict: Liveness status

**File:** `app/routers/health.py`

---

#### `GET /health/metrics/qdrant`

Qdrant operation metrics for monitoring performance.

Returns metrics including:
- Search operation counts and average latency
- Upsert operation counts and average latency
- Document counts processed
- Retry counts
- Error counts

**File:** `app/routers/health.py`

---

#### `GET /health/ready`

Kubernetes-style readiness probe.

Returns 200 only if critical services are ready to handle traffic.
Used by load balancers to determine if instance should receive traffic.

Returns:
    dict: Readiness status with critical service check

**File:** `app/routers/health.py`

---

### identity

#### `POST /team/login`

Team member login endpoint

Replicates the exact behavior of Node.js /api/auth/team/login endpoint.

- Validates email and PIN format
- Authenticates user against database
- Generates JWT token (7 days expiry)
- Sets httpOnly cookie with JWT token
- Returns user data and permissions

Returns:
    LoginResponse with JWT token and user data

**Response Model:** `LoginResponse`

**File:** `app/modules/identity/router.py`

---

### image

#### `POST /api/v1/image/generate`

Generate images using Google Imagen API

Args:
    request: Image generation request with prompt and parameters

Returns:
    ImageGenerationResponse with generated images or error

**Response Model:** `ImageGenerationResponse`

**File:** `app/routers/image_generation.py`

---

### ingestion

#### `GET /api/ingest/stats`

Get current database statistics.

Returns total documents, tier distribution, and collection info.

**File:** `app/routers/ingest.py`

---

#### `POST /api/ingest/batch`

Process all books in a directory.

- **directory_path**: Path to directory containing books
- **file_patterns**: File patterns to match (default: ["*.pdf", "*.epub"])
- **skip_existing**: Skip books already in database

**Response Model:** `BatchIngestionResponse`

**File:** `app/routers/ingest.py`

---

#### `POST /api/ingest/file`

Ingest a book from local file path.

- **file_path**: Path to PDF or EPUB file
- **title**: Optional book title
- **author**: Optional author name
- **tier_override**: Optional manual tier classification

**Response Model:** `BookIngestionResponse`

**File:** `app/routers/ingest.py`

---

#### `POST /api/ingest/upload`

Upload and ingest a single book.

- **file**: PDF or EPUB file
- **title**: Optional book title (auto-detected if not provided)
- **author**: Optional author name
- **tier_override**: Optional manual tier (S/A/B/C/D)

**Response Model:** `BookIngestionResponse`

**File:** `app/routers/ingest.py`

---

### knowledge

#### `GET /api/search/health`

Quick health check for search service

**File:** `app/modules/knowledge/router.py`

---

#### `POST /api/search/`

Semantic search with tier-based access control.

- **query**: Search query text
- **level**: User access level (0-3)
- **limit**: Maximum results (1-50, default 5)
- **tier_filter**: Optional specific tier filter

Returns relevant book chunks filtered by user's access level.

REFACTORED: Now uses SearchService (canonical retriever) instead of KnowledgeService singleton.
This ensures consistent RAG pipeline across chat agentic and /api/search endpoints.

**Response Model:** `SearchResponse`

**File:** `app/modules/knowledge/router.py`

---

### legal-ingestion

#### `GET /api/legal/collections/stats`

Get statistics for legal document collection.

Args:
    collection_name: Collection name to query

Returns:
    Collection statistics

**File:** `app/routers/legal_ingest.py`

---

#### `POST /api/legal/ingest`

Ingest a single legal document through the specialized pipeline.

Pipeline stages:
1. Clean: Remove headers/footers/noise
2. Extract Metadata: Type, number, year, topic
3. Parse Structure: BAB, Pasal, Ayat hierarchy
4. Chunk: Pasal-aware chunking with context injection
5. Embed & Store: Generate embeddings and store in Qdrant

Args:
    request: Legal ingestion request with file path and options

Returns:
    Ingestion result with metadata and statistics

**Response Model:** `LegalIngestResponse`

**File:** `app/routers/legal_ingest.py`

---

#### `POST /api/legal/ingest-batch`

Ingest multiple legal documents in batch.

Args:
    file_paths: List of file paths to ingest
    collection_name: Override collection name (optional)

Returns:
    Batch ingestion results

**File:** `app/routers/legal_ingest.py`

---

### media

#### `POST /media/generate-image`

Generate an image from a text prompt.

**File:** `app/routers/media.py`

---

#### `POST /media/upload`

Upload a file (image, audio, doc) to the server.
Returns the URL/path to the file.

**File:** `app/routers/media.py`

---

### memory

#### `DELETE /api/memory/{memory_id}`

Delete memory from vector store

**File:** `app/routers/memory_vector.py`

---

#### `GET /api/memory/health`

Health check for memory vector service

**File:** `app/routers/memory_vector.py`

---

#### `GET /api/memory/stats`

Get memory collection statistics

**File:** `app/routers/memory_vector.py`

---

#### `POST /api/memory/embed`

Generate embedding for text.
Uses sentence-transformers (FREE, local) by default.

**Response Model:** `EmbedResponse`

**File:** `app/routers/memory_vector.py`

---

#### `POST /api/memory/init`

Reinitialize the semantic memory collection after deployments or resets.

**Response Model:** `InitResponse`

**File:** `app/routers/memory_vector.py`

---

#### `POST /api/memory/search`

Semantic search across all memories using vector similarity.

Supports metadata filtering:
- userId: Filter by specific user
- entities: Filter by entity (use {"entities": {"$contains": "zero"}})

**Response Model:** `MemorySearchResponse`

**File:** `app/routers/memory_vector.py`

---

#### `POST /api/memory/similar`

Find memories similar to a given memory.
Uses the stored memory's embedding to find neighbors.

**Response Model:** `MemorySearchResponse`

**File:** `app/routers/memory_vector.py`

---

#### `POST /api/memory/store`

Store memory in Qdrant for semantic search.

Metadata should include:
- userId: User ID
- type: Memory type (profile, expertise, event, etc)
- timestamp: ISO timestamp
- entities: Comma-separated entities

**File:** `app/routers/memory_vector.py`

---

### performance

#### `GET /api/performance/cache/stats`

Get cache statistics

**File:** `app/routers/performance.py`

---

#### `GET /api/performance/metrics`

Get performance metrics

**File:** `app/routers/performance.py`

---

#### `POST /api/performance/clear-cache`

Clear all caches

**File:** `app/routers/performance.py`

---

#### `POST /api/performance/clear-cache/embedding`

Clear embedding cache only

**File:** `app/routers/performance.py`

---

#### `POST /api/performance/clear-cache/search`

Clear search cache only

**File:** `app/routers/performance.py`

---

### sessions

#### `DELETE /api/sessions/{session_id}`

Delete a session

**File:** `app/routers/session.py`

---

#### `GET /api/sessions/analytics/overview`

Get analytics about all sessions

**File:** `app/routers/session.py`

---

#### `GET /api/sessions/health`

Health check for session service

**File:** `app/routers/session.py`

---

#### `GET /api/sessions/{session_id}`

Get conversation history for a session

**File:** `app/routers/session.py`

---

#### `GET /api/sessions/{session_id}/export`

Export session conversation

**File:** `app/routers/session.py`

---

#### `GET /api/sessions/{session_id}/info`

Get session metadata

**File:** `app/routers/session.py`

---

#### `POST /api/sessions/cleanup`

Cleanup expired sessions (no-op, Redis handles automatically)

**File:** `app/routers/session.py`

---

#### `POST /api/sessions/create`

Create a new conversation session

**File:** `app/routers/session.py`

---

#### `POST /api/sessions/{session_id}/extend`

Extend session TTL

**File:** `app/routers/session.py`

---

#### `POST /api/sessions/{session_id}/extend-custom`

Extend session TTL to custom duration

**File:** `app/routers/session.py`

---

#### `PUT /api/sessions/{session_id}`

Update conversation history for a session

**File:** `app/routers/session.py`

---

#### `PUT /api/sessions/{session_id}/ttl`

Update session with custom TTL

**File:** `app/routers/session.py`

---

### team-activity

#### `GET /api/team/activity/monthly`

Get monthly work summary (ADMIN ONLY)

Returns total hours, days worked, and averages for each team member.

**File:** `app/routers/team_activity.py`

---

#### `GET /api/team/activity/weekly`

Get weekly work summary (ADMIN ONLY)

Returns total hours, days worked, and averages for each team member.

**File:** `app/routers/team_activity.py`

---

#### `GET /api/team/export`

Export timesheet data (ADMIN ONLY)

Returns CSV file with all work hours in the specified date range.

**File:** `app/routers/team_activity.py`

---

#### `GET /api/team/health`

Health check for team activity service

**File:** `app/routers/team_activity.py`

---

#### `GET /api/team/hours`

Get work hours for a specific date (ADMIN ONLY)

Returns all team members' work hours for the specified date.

**File:** `app/routers/team_activity.py`

---

#### `GET /api/team/my-status`

Get my current work status

Returns:
- Current online/offline status
- Today's hours worked
- This week's summary

**Response Model:** `UserStatusResponse`

**File:** `app/routers/team_activity.py`

---

#### `GET /api/team/status`

Get current online status of all team members (ADMIN ONLY)

Shows who is currently clocked in and who is offline.

**File:** `app/routers/team_activity.py`

---

#### `POST /api/team/clock-in`

Clock in for work day

Team members use this to start their work day.
One clock-in per day allowed.

**Response Model:** `ClockResponse`

**File:** `app/routers/team_activity.py`

---

#### `POST /api/team/clock-out`

Clock out for work day

Team members use this to end their work day.
Must be clocked in first.

**Response Model:** `ClockResponse`

**File:** `app/routers/team_activity.py`

---

### team-analytics

#### `GET /api/team-analytics/burnout`

Detect early warning signs of burnout

**File:** `app/routers/team_analytics.py`

---

#### `GET /api/team-analytics/optimal-hours`

Identify most productive time windows

**File:** `app/routers/team_analytics.py`

---

#### `GET /api/team-analytics/patterns`

Analyze work hour patterns and habits

**File:** `app/routers/team_analytics.py`

---

#### `GET /api/team-analytics/productivity`

Calculate productivity scores for team members

**File:** `app/routers/team_analytics.py`

---

#### `GET /api/team-analytics/team-insights`

Generate comprehensive team collaboration insights

**File:** `app/routers/team_analytics.py`

---

#### `GET /api/team-analytics/trends/{user_email}`

Analyze performance trends over time

**File:** `app/routers/team_analytics.py`

---

#### `GET /api/team-analytics/workload-balance`

Analyze workload distribution across team

**File:** `app/routers/team_analytics.py`

---

## Modules

### Agents

#### `agents.__init__`

Agents Module - Autonomous Agent Framework
Contains agent implementations for conversation training, client prediction,
and knowledge graph building.

#### `agents.agents.__init__`

Agents Submodule - Individual Agent Implementations
Contains the core agent classes for different autonomous functions.

#### `agents.agents.client_value_predictor`

üí∞ CLIENT LIFETIME VALUE PREDICTOR
Predicts high-value clients and automatically nurtures them

Refactored to use modular services:
- ClientScoringService: Calculate LTV scores
- ClientSegmentationService: Segment clients and calculate risk
- NurturingMessageService: Generate personalized messages
- WhatsAppNotificationService: Send messages via Twilio

#### `agents.agents.conversation_trainer`

ü§ñ AUTONOMOUS CONVERSATION TRAINER
Learns from successful conversations and improves prompts automatically

#### `agents.agents.knowledge_graph_builder`

üï∏Ô∏è KNOWLEDGE GRAPH AUTO-BUILDER
Automatically builds and maintains a knowledge graph from all data sources

Refactored to use modular services:
- KnowledgeGraphSchema: Manage database schema
- EntityExtractor: Extract entities from text using AI
- RelationshipExtractor: Extract relationships between entities using AI
- KnowledgeGraphRepository: Database operations for entities and relationships

#### `agents.agents.schemas`

Pydantic schemas for agent input validation

#### `agents.services.__init__`

Agent Services - Modular services extracted from God Objects

Services:
- Client Scoring & Segmentation
- Nurturing & Notifications
- Knowledge Graph Operations

#### `agents.services.client_scoring`

Client Scoring Service

Responsibility: Calculate client lifetime value (LTV) scores from database data.

#### `agents.services.client_segmentation`

Client Segmentation Service

Responsibility: Segment clients and calculate risk levels based on LTV scores.

#### `agents.services.kg_extractors`

Knowledge Graph Extractors

Responsibility: Extract entities and relationships from text using AI.

#### `agents.services.kg_repository`

Knowledge Graph Repository

Responsibility: Database operations for knowledge graph (entities, relationships, queries).

#### `agents.services.kg_schema`

Knowledge Graph Schema Service

Responsibility: Manage knowledge graph database schema.

#### `agents.services.nurturing_message`

Nurturing Message Service

Responsibility: Generate personalized nurturing messages using AI.

#### `agents.services.whatsapp_notification`

WhatsApp Notification Service

Responsibility: Send WhatsApp messages via Twilio.

### App

#### `app.__init__`

ZANTARA RAG System - FastAPI Application

#### `app.auth.__init__`

Unified Authentication Module
Consolidates auth validation logic from multiple files

#### `app.auth.validation`

Unified Authentication Validation Module
Consolidates auth validation logic from main_cloud.py, hybrid_auth.py, and auth.py

This module provides a single source of truth for authentication validation,
eliminating code duplication across the codebase.

#### `app.core.__init__`

NUZANTARA PRIME - Core Module
Centralized configuration and core utilities

#### `app.core.config`

NUZANTARA PRIME - Centralized Configuration
All environment variables centralized using pydantic-settings

#### `app.core.constants`

NUZANTARA PRIME - Application Constants
Centralized constants to replace magic numbers throughout the codebase

#### `app.core.service_health`

ZANTARA RAG - Service Health Registry

Provides centralized tracking of service health status for fail-fast behavior
and health-based degradation in production environments.

#### `app.decorators.auth`

Authentication Decorators
Provides decorators for endpoint security classification and access control

#### `app.dependencies`

FastAPI Dependency Injection

Centralized dependencies for all routers to avoid circular imports.
Provides fail-fast behavior with clear error messages for service unavailability.

ARCHITECTURE:
- Services are initialized in main_cloud.py::initialize_services()
- Services are stored in app.state (FastAPI standard)
- This module provides getter functions that routers can use via Depends()

PATTERN:
- All dependencies use Request object to access app.state
- This allows easy mocking in tests
- Fail-fast: raises HTTPException if service not initialized

See: app/main_cloud.py::initialize_services() for initialization logic

#### `app.feature_flags`

ZANTARA Feature Flags
Control experimental and optional features via environment variables

#### `app.main_cloud`

FastAPI entrypoint for the ZANTARA RAG backend.

Responsibilities:
* Initialize shared services (SearchService, ZantaraAI, ToolExecutor)
* Mount all API routers
* Expose streaming endpoint (/bali-zero/chat-stream)
* Configure CORS and health checks

#### `app.metrics`

Enhanced Prometheus Metrics for ZANTARA-PERFECT-100
Provides detailed system monitoring and performance tracking

#### `app.models`

ZANTARA RAG - Pydantic Models

#### `app.modules.crm.__init__`

NUZANTARA PRIME - CRM Module
Client, Practice, and Interaction management

#### `app.modules.crm.models`

NUZANTARA PRIME - CRM Module Data Layer
SQLModel models for CRM system (clients, practices, interactions)

#### `app.modules.identity.__init__`

NUZANTARA PRIME - Identity Module
Authentication, Users, and Sessions management

#### `app.modules.identity.models`

NUZANTARA PRIME - Identity Module Data Layer
SQLModel models mapping to existing Node.js backend tables

#### `app.modules.identity.router`

NUZANTARA PRIME - Identity Router
HTTP API endpoints for authentication

#### `app.modules.identity.service`

NUZANTARA PRIME - Identity Service
Business logic for authentication and user management

#### `app.modules.knowledge.__init__`

NUZANTARA PRIME - Knowledge Module
RAG, Search, and Vector Database Interface

#### `app.modules.knowledge.router`

NUZANTARA PRIME - Knowledge Router
HTTP interface for RAG/Search operations

REFACTORED: Now uses SearchService (canonical retriever) instead of KnowledgeService singleton.
This eliminates duplicate RAG pipelines and cache collisions.

#### `app.modules.knowledge.service`

NUZANTARA PRIME - Knowledge Service
Business logic for RAG, Search, and Vector Database operations

DEPRECATED: This service is deprecated in favor of SearchService (canonical retriever).
It is kept only as a fallback for test/local boot scenarios where SearchService may not be initialized.

Migration path:
- Use SearchService from app.state.search_service (injected in main_cloud.py)
- For /api/search endpoint, use get_search_service(request) helper in router.py

#### `app.routers.agentic_rag`

Agentic RAG API Router

#### `app.routers.agents`

ZANTARA Agentic Functions Router
Exposes all 10 advanced agentic capabilities as REST API endpoints

Phase 1-2: Foundation Agents (6)
Phase 3: Orchestration Agents (2)
Phase 4: Advanced Intelligence (1)
Phase 5: Automation (1)

Performance Optimizations:
- Redis caching (5 min TTL for status endpoints)
- Rate limiting (prevents abuse)
- Request deduplication

SECURITY: All endpoints require authentication (added 2025-12-03)

#### `app.routers.auth`

JWT Authentication Router
Real email+PIN authentication using bcrypt and JWT tokens

#### `app.routers.autonomous_agents`

TIER 1 AUTONOMOUS AGENTS - HTTP Endpoints
Provides HTTP API for orchestrator to trigger autonomous agents

Agents:
1. Conversation Quality Trainer
2. Client LTV Predictor & Nurturing
3. Knowledge Graph Builder

#### `app.routers.collective_memory`

Collective Memory API Router
Endpoints for managing shared knowledge across users

#### `app.routers.conversations`

ZANTARA Conversations Router
Endpoints for persistent conversation history with PostgreSQL
+ Auto-CRM population from conversations

SECURITY: All endpoints require JWT authentication (added 2025-12-03)
User identity is taken from JWT token, NOT from request parameters.

Refactored: Migrated to asyncpg with connection pooling (2025-12-07)

#### `app.routers.crm_clients`

ZANTARA CRM - Clients Management Router
Endpoints for managing client data (anagrafica clienti)

Refactored: Migrated to asyncpg with connection pooling (2025-12-07)

#### `app.routers.crm_interactions`

ZANTARA CRM - Interactions Tracking Router
Endpoints for logging and retrieving team-client interactions

Refactored: Migrated to asyncpg with connection pooling (2025-12-07)

#### `app.routers.crm_practices`

ZANTARA CRM - Practices Management Router
Endpoints for managing practices (KITAS, PT PMA, Visas, etc.)

Refactored: Migrated to asyncpg with connection pooling (2025-12-07)

#### `app.routers.crm_shared_memory`

ZANTARA CRM - Shared Memory Router
Team-wide memory access for AI and team members
Enables queries like "clients with upcoming renewals", "active practices for John Smith", etc.

Refactored: Migrated to asyncpg with connection pooling (2025-12-07)

#### `app.routers.episodic_memory`

Episodic Memory API Router
Endpoints for managing user timeline events and experiences

#### `app.routers.handlers`

Handlers Registry Endpoint
Auto-discovers and exposes all available handlers/tools for ZANTARA

#### `app.routers.health`

ZANTARA RAG - Health Check Router

Provides health check endpoints for monitoring service status:
- /health - Basic health check for load balancers
- /health/detailed - Comprehensive service status for debugging

#### `app.routers.image_generation`

Image Generation Router - Handles image generation requests

#### `app.routers.ingest`

ZANTARA RAG - Ingestion Router
Book ingestion endpoints

#### `app.routers.intel`

Intel News API - Search and manage Bali intelligence news

#### `app.routers.legal_ingest`

Legal Document Ingestion Router
API endpoints for Indonesian legal document ingestion pipeline

#### `app.routers.memory_vector`

ZANTARA RAG - Memory Vector Router
Semantic memory storage and search using Qdrant
Complements Firestore-based memory system with vector search capabilities

#### `app.routers.oracle_ingest`

ORACLE INGEST API Router
Endpoint per caricare massivamente documenti legali su Qdrant

POST /api/oracle/ingest - Bulk upload di chunks con embeddings

#### `app.routers.oracle_universal`

=======================================
ZANTARA v5.3 (Ultra Hybrid) - Universal Oracle API
=======================================

Author: Senior DevOps Engineer & Database Administrator
Version: 5.3.1 (Refactored)
Production Status: READY
Description:
Production-ready hybrid RAG system integrating:
- Qdrant Vector Database (Semantic Search)
- Google Drive Integration (PDF Document Repository)
- Google Gemini 2.5 Flash (Reasoning Engine)
- User Identity & Localization System (PostgreSQL)
- Multimodal Capabilities (Text + Audio)
- Comprehensive Error Handling & Logging

Language Protocol:
- Source Code & Logs: ENGLISH (Standard)
- Knowledge Base: Bahasa Indonesia (Indonesian Laws)
- WebApp UI: ENGLISH
- AI Responses: User's preferred language (from users.meta_json.language)

#### `app.routers.performance`

Performance Optimization API Router
Exposes PerformanceMonitor and cache management via REST API endpoints

#### `app.routers.root_endpoints`

Root Endpoints Router
Handles root-level endpoints like /, /api/csrf-token, /api/dashboard/stats

#### `app.routers.session`

Session Management API Router
Exposes SessionService functionality via REST API endpoints

#### `app.routers.team_activity`

Team Activity API Router
Endpoints for team timesheet and activity tracking

#### `app.routers.team_analytics`

Team Analytics API Router
Exposes TeamAnalyticsService functionality via REST API endpoints

#### `app.routers.websocket`

WebSocket Router & Connection Manager
Handles real-time notifications via Redis Pub/Sub
Replaces Node.js websocket.ts

#### `app.services.api_key_auth`

API Key Authentication Service
Provides simple API key validation to bypass database dependency for testing

#### `app.setup.__init__`

Application Setup Module
Handles router registration

#### `app.setup.router_registration`

Router Registration Module
Centralizes all router inclusion logic

#### `app.utils.cookie_auth`

Cookie-based authentication utilities for httpOnly JWT tokens.

This module provides secure cookie management for authentication:
- httpOnly JWT cookie (prevents XSS token theft)
- CSRF cookie (readable by JS for double-submit pattern)
- Environment-aware domain configuration

#### `app.utils.error_handlers`

Standardized error handling utilities for routers.

Provides consistent error handling across all API endpoints.

#### `app.utils.logging_utils`

Standardized logging utilities for routers.

Provides consistent logging patterns across all API endpoints.

#### `app.utils.state_helpers`

State Helpers Module
Provides type-safe access to app.state and request.state attributes

### Cli

#### `cli.__init__`

NUZANTARA PRIME - CLI Module

Unified command-line interfaces for:
- Ingestion operations
- Migration management
- Health checks

#### `cli.ingestion_cli`

NUZANTARA PRIME - Unified Ingestion CLI

Provides a single command-line interface for all ingestion operations.
Replaces fragmented ingestion scripts.

Usage:
    python -m cli.ingestion_cli ingest team-members
    python -m cli.ingestion_cli ingest conversations --source /path/to/data
    python -m cli.ingestion_cli ingest laws --file /path/to/law.pdf
    python -m cli.ingestion_cli list

### Core

#### `core.__init__`

ZANTARA RAG - Core Components

#### `core.cache`

Redis Caching Layer for ZANTARA
Provides intelligent caching for expensive operations

Features:
- TTL-based expiration
- Automatic key generation
- Cache invalidation
- Hit/miss metrics

#### `core.chunker`

Minimal Chunker stub for tests.

#### `core.embeddings`

ZANTARA RAG - Embeddings Generation
Supports both OpenAI and Sentence Transformers

#### `core.legal.__init__`

Legal Document Processing Module
Specialized pipeline for Indonesian legal documents (UU, PP, Keppres, etc.)

#### `core.legal.chunker`

Legal Document Chunker - Stage 4: The Butcher
Pasal-aware semantic chunking with context injection

#### `core.legal.cleaner`

Legal Document Cleaner - Stage 1: The Washer
Removes non-content artifacts from Indonesian legal documents

#### `core.legal.constants`

Constants for Indonesian Legal Document Processing
Regex patterns, keywords, and structure markers

#### `core.legal.hierarchical_indexer`

Hierarchical Document Indexer
Crea relazioni parent-child per retrieval gerarchico

#### `core.legal.metadata_extractor`

Legal Metadata Extractor - Stage 2: The Librarian
Extracts structured metadata from Indonesian legal documents

#### `core.legal.structure_parser`

Legal Structure Parser - Stage 3: The Architect
Recognizes hierarchical structure of Indonesian legal documents

#### `core.parsers`

ZANTARA RAG - Document Parsers
Extract text from PDF and EPUB files

#### `core.plugins.__init__`

ZANTARA Unified Plugin Architecture

This module provides the core plugin system for ZANTARA, enabling:
- Standardized plugin interfaces
- Plugin discovery and registration
- Lifecycle management
- Performance monitoring
- Caching and rate limiting

#### `core.plugins.executor`

Plugin Executor

Executes plugins with performance monitoring, caching, rate limiting, and error handling.

#### `core.plugins.plugin`

Core Plugin Base Classes

Defines the base plugin interface that all ZANTARA plugins must implement.

#### `core.plugins.registry`

Plugin Registry

Central registry for all plugins. Handles loading, discovery, versioning, and lifecycle.

#### `core.qdrant_db`

ZANTARA RAG - Vector Database (Qdrant)
Async Qdrant client wrapper for embeddings storage and retrieval

Uses httpx for async HTTP requests with connection pooling.
All operations are async to avoid blocking the event loop.

#### `core.reranker`

ZANTARA RAG - Semantic Re-ranker (Ze-Rank 2 API)
Implements external API-based re-ranking for high-precision retrieval without local CPU load.

### Data

#### `data.team_members`

ZANTARA Team Members Database

Importato dal JSON originale per uso programmatico

### Db

#### `db.__init__`

NUZANTARA PRIME - Database Module

#### `db.migrate`

NUZANTARA PRIME - Migration CLI Tool
Centralized tool for managing database migrations

#### `db.migration_base`

NUZANTARA PRIME - Base Migration Framework
Provides base classes and utilities for database migrations

#### `db.migration_manager`

NUZANTARA PRIME - Migration Manager
Centralized migration management system

### Llm

#### `llm.__init__`

LLM clients for ZANTARA AI

#### `llm.fallback_messages`

Fallback Messages - Localized error messages

Centralized fallback messages for error scenarios.

#### `llm.prompt_manager`

Prompt Manager - Handles system prompt loading and building

Separated from ZantaraAIClient to follow Single Responsibility Principle.

#### `llm.retry_handler`

Retry Handler - Centralized retry logic with exponential backoff

Separated from ZantaraAIClient to follow Single Responsibility Principle.

#### `llm.token_estimator`

Token Estimator - Accurate token counting for cost tracking

Uses tiktoken for accurate token estimation instead of approximations.

#### `llm.zantara_ai_client`

ZANTARA AI Client - Primary engine for all conversational AI

AI Models Architecture:
- PRIMARY: Google Gemini 2.5 Pro (production)

Configuration:
- GOOGLE_API_KEY: API key for Gemini (primary)

UPDATED 2025-12-07:
- Refactored for better separation of concerns
- Added PromptManager, RetryHandler, TokenEstimator
- Improved error handling and performance
- Added input validation and connection pooling

### Middleware

#### `middleware.error_monitoring`

Error Monitoring Middleware
Captures 4xx/5xx HTTP errors and sends alerts

#### `middleware.hybrid_auth`

Hybrid Authentication Middleware - Fail-Closed Implementation
Combines API Key, Cookie JWT, and Header JWT authentication for flexible access control.

Authentication Priority:
1. API Key (X-API-Key header) - for service-to-service communication
2. Cookie JWT (nz_access_token) - for browser clients with httpOnly cookies
3. Header JWT (Authorization: Bearer) - backward compatibility

SECURITY POLICY: Fail-Closed - any authentication system error denies access

#### `middleware.rate_limiter`

Rate Limiting Middleware for ZANTARA
Prevents API abuse and ensures fair usage

Features:
- IP-based rate limiting
- User-based rate limiting
- Configurable limits per endpoint
- Redis-backed for distributed systems

### Migrations

#### `migrations.001_fix_missing_tables`

Migration: Fix missing PostgreSQL tables
Date: 2025-10-19
Purpose: Create cultural_knowledge, query_clusters tables and fix memory_facts.id

#### `migrations.apply_migration_007`

One-time script to apply migration 007 via Fly.io

#### `migrations.apply_migration_010`

One-time script to apply migration 010 via Fly.io or local
Migration: Fix team_members schema alignment

#### `migrations.apply_migration_012`

Apply Migration 012: Fix Production Schema Issues
Adds missing conversation_id column to interactions table

#### `migrations.apply_migration_013`

Apply Migration 013: Agentic RAG Tables
Creates tables for Parent-Child Retrieval and Golden Router

#### `migrations.apply_migration_014`

Apply Migration 014: Knowledge Graph Tables
Creates tables for Knowledge Graph

#### `migrations.apply_migration_015`

Apply Migration 015: Add Drive Columns

#### `migrations.migrate_crm_schema`

Apply CRM System Schema Migration
Connects to Fly.io PostgreSQL and applies migration 007

#### `migrations.migration_001`

Migration 001: Fix missing PostgreSQL tables
Creates cultural_knowledge and query_clusters tables, fixes memory_facts.id

#### `migrations.migration_007`

Migration 007: CRM System Schema
Creates tables for CRM system (team_members, clients, practices, interactions, etc.)

#### `migrations.migration_010`

Migration 010: Fix team_members schema alignment
Adds missing columns to align with Python User model

#### `migrations.migration_012`

Migration 012: Fix Production Schema Issues
Adds missing conversation_id column to interactions table

#### `migrations.migration_013`

Migration 013: Agentic RAG Tables
Creates tables for Parent-Child Retrieval and Golden Router

#### `migrations.migration_014`

Migration 014: Knowledge Graph Tables
Creates tables for Knowledge Graph

#### `migrations.migration_015`

Migration 015: Add Drive Columns
Adds Google Drive metadata to parent_documents table

#### `migrations.migration_016`

Migration 016: Add Summary to Parent Documents
Adds summary column to parent_documents table

#### `migrations.migration_018`

Migration 018: Collective Memory System
Creates tables for shared knowledge learned from multiple users

#### `migrations.migration_019`

Migration 019: Episodic Memory System
Creates table for storing timeline of user events and experiences

#### `migrations.migration_020`

Migration 020: Collective Memory Vector Search
Sets up Qdrant collection and backfills embeddings for existing memories

#### `migrations.migration_021`

Migration 021: Memory-Knowledge Graph Integration
Links memory_facts and episodic_memories to kg_entities

### Plugins

#### `plugins.__init__`

ZANTARA Plugins Directory

This directory contains all plugin implementations organized by category.

#### `plugins.bali_zero.__init__`

Bali Zero service plugins

#### `plugins.bali_zero.pricing_plugin`

Pricing Plugin - Official Bali Zero Pricing

Migrated from: backend/services/zantara_tools.py -> _get_pricing

#### `plugins.team.__init__`

Team management plugins

#### `plugins.team.list_members_plugin`

Team Members List Plugin

Migrated from: backend/services/zantara_tools.py -> _get_team_members_list

#### `plugins.team.search_member_plugin`

Team Member Search Plugin

Migrated from: backend/services/zantara_tools.py -> _search_team_member

### Prompts

#### `prompts.__init__`

Prompts package for Nuzantara AI - contains Jaksel personality and system prompts.

### Root

#### `__init__`

ZANTARA RAG Backend Package

#### `verify_draft_pattern`

Test Draft-Verify Logic
Simulates a query that might cause hallucinations (fake law) to see if Verifier catches it.

### Self_Healing

#### `self_healing.backend_agent`

ü§ñ ZANTARA Backend Self-Healing Agent

Autonomous agent that monitors backend service health and auto-fixes issues
Runs continuously on each Fly.io service (RAG, Memory, etc.)

Features:
- Health checks (API, DB, Redis, Qdrant)
- Auto-restart on failures
- Memory leak detection
- Database connection pool management
- API endpoint monitoring
- Reports to Central Orchestrator

### Services

#### `services.__init__`

ZANTARA RAG - Services

#### `services.ai_crm_extractor`

ZANTARA CRM - AI Entity Extraction Service
Uses ZANTARA AI to extract structured data from conversations for CRM auto-population

#### `services.alert_service`

Alert Notification Service
Sends alerts for critical errors via Slack, Discord, and logging

#### `services.analytics.__init__`

Analytics Module
Specialized analytics services extracted from TeamAnalyticsService

#### `services.analytics.burnout_detector`

Burnout Detector Service
Responsibility: Burnout signal detection

#### `services.analytics.optimal_hours`

Optimal Hours Service
Responsibility: Optimal hours identification

#### `services.analytics.pattern_analyzer`

Pattern Analyzer Service
Responsibility: Work pattern analysis

#### `services.analytics.performance_trend`

Performance Trend Service
Responsibility: Performance trend analysis

#### `services.analytics.productivity_scorer`

Productivity Scorer Service
Responsibility: Productivity scoring

#### `services.analytics.team_insights`

Team Insights Service
Responsibility: Team collaboration insights

#### `services.analytics.workload_balance`

Workload Balance Service
Responsibility: Workload distribution analysis

#### `services.audit_service`

ZANTARA Audit Service
Handles security logging and system audit trails for compliance and debugging.
Replaces Node.js audit-trail.ts

#### `services.auto_crm_service`

ZANTARA CRM - Auto-Population Service
Automatically creates/updates clients and practices from chat conversations

REFACTORED 2025-12-07:
- Migrated from psycopg2 to asyncpg with connection pooling
- Uses centralized database pool from app.state (dependency injection)
- Batched queries to reduce N+1 problem
- Improved error handling

REFACTORED 2025-12-07 (Phase 2):
- Removed own connection pool creation
- Uses centralized pool from get_database_pool() dependency
- Better integration with FastAPI dependency injection

#### `services.auto_ingestion_orchestrator`

Auto-Ingestion Orchestrator - Phase 5 (Automation Agent)

Automatically monitors external sources and updates Qdrant collections
with new regulations, laws, and business information.

Monitored Sources:
- OSS website (KBLI updates)
- Ditjen Imigrasi (visa regulations)
- DJP (tax circulars)
- BKPM newsletters
- Legal databases (for legal_updates)

Process:
1. Daily scrape of monitored sources
2. LLM filter: "Is this a regulation change?"
3. Extract key information
4. Generate embeddings
5. Add to relevant collection (tax_updates, legal_updates, etc.)
6. Notify admin of updates
7. Trigger collection health check

Integration with bali-intel-scraper:
- Extends existing scraper with structured ingestion
- Uses same 2-tier filtering (LLAMA ‚Üí ZANTARA AI)
- Adds to Qdrant instead of just logging

#### `services.autonomous_research_service`

Autonomous Research Agent - Phase 4 (Advanced Agent)

Self-directed research agent that iteratively explores Qdrant collections
to answer complex or ambiguous queries without human intervention.

Example: "How to open a crypto company in Indonesia?"
‚Üí Iteration 1: Search kbli_eye ‚Üí "crypto" not in KBLI database
‚Üí Iteration 2: Expand to legal_updates ‚Üí finds OJK crypto regulation 2024
‚Üí Iteration 3: Search tax_genius ‚Üí crypto tax treatment
‚Üí Iteration 4: Search visa_oracle ‚Üí fintech director visa requirements
‚Üí Synthesis: Comprehensive answer despite no direct KBLI match

Key Features:
- Self-directed query expansion
- Iterative collection exploration
- Semantic similarity for expansion
- Reasoning chain transparency
- Automatic termination when sufficient info gathered

#### `services.autonomous_scheduler`

ü§ñ AUTONOMOUS SCHEDULER SERVICE
Centralizes scheduling of all autonomous agents and background tasks.

Managed Services:
1. Auto-Ingestion Orchestrator - Daily regulatory updates (every 24h)
2. Backend Self-Healing Agent - Continuous health monitoring (every 30s)
3. Conversation Trainer Agent - Learn from successful conversations (every 6h)
4. Client Value Predictor Agent - Nurture high-value clients (every 12h)
5. Knowledge Graph Builder Agent - Build knowledge graphs (every 4h)

#### `services.citation_service`

Citation Service - Add inline citations and source references to AI responses
Enhances credibility and transparency by showing where information comes from

This service enables AI to cite sources using inline references [1], [2] and
provide full source details at the end of responses, building user trust.

Author: ZANTARA Development Team
Date: 2025-10-16

#### `services.clarification_service`

Clarification Service - Detect ambiguous queries and request clarification
Improves response quality by ensuring the AI understands user intent clearly

This service detects when a user's question is ambiguous or incomplete,
prompting for clarification before generating a potentially incorrect response.

Author: ZANTARA Development Team
Date: 2025-10-16

#### `services.classification.__init__`

Classification Module
Intent classification and query type detection

#### `services.classification.intent_classifier`

Intent Classifier Module
Fast pattern-based intent classification without AI cost

#### `services.client_journey_orchestrator`

Client Journey Orchestrator - Phase 3 (Orchestration Agent #1)

Manages multi-step business workflows with automatic progress tracking,
document collection, and timeline management.

REFACTORED: Uses sub-services following Single Responsibility Principle
- JourneyTemplatesService: Template management
- JourneyBuilderService: Journey creation
- PrerequisitesCheckerService: Prerequisites validation
- StepManagerService: Step lifecycle management
- ProgressTrackerService: Progress tracking

Example Journey: "PT PMA Setup"
‚Üí Steps:
  1. Company name approval (KEMENKUMHAM) - Prerequisites: None
  2. Notary deed preparation - Prerequisites: Step 1 complete
  3. NIB application (OSS) - Prerequisites: Step 2 complete
  4. NPWP registration - Prerequisites: Step 3 complete
  5. Bank account opening - Prerequisites: Step 4 complete
  6. Virtual office setup - Prerequisites: Step 5 complete
  7. Director KITAS application - Prerequisites: Step 1-6 complete

Each step tracks:
- Status (pending/in_progress/completed/blocked)
- Required documents
- Estimated timeline
- Actual completion date
- Blocking issues

#### `services.collaborator_service`

Collaborator Service
--------------------

Loads real Bali Zero team data from JSON and provides search/list/stats helpers.
Replaces the legacy identity layers with a transparent, easy-to-edit dataset.

#### `services.collection_health_service`

Collection Health Monitor - Phase 3

Monitors the health and quality of all Qdrant collections:
- Last update timestamps
- Document counts
- Query hit rates
- Average confidence scores
- Staleness detection
- Actionable recommendations

Provides admin dashboard with collection health metrics.

#### `services.collection_manager`

Collection Manager Service
Manages Qdrant collection lifecycle and access

Extracted from SearchService to follow Single Responsibility Principle.

#### `services.collection_warmup_service`

Collection Warmup Service

Handles warming up vector database collections to improve first-query latency.

Extracted from SearchService to follow Single Responsibility Principle.
Pre-loads critical collections and generates dummy embeddings to reduce cold-start latency.

#### `services.collective_memory_emitter`

Collective Memory Event Emitter
Emette eventi SSE per memoria collettiva al frontend

#### `services.collective_memory_service`

ZANTARA Collective Memory Service

Manages shared knowledge learned from multiple users.
Facts become "collective" when confirmed by 3+ different users.

Key features:
- Contribution tracking with full user audit trail
- Automatic promotion to collective when threshold reached
- Confidence scoring based on confirmations vs refutations
- Category-based organization (process, location, provider, etc.)
- Query-aware semantic retrieval via Qdrant (v1.5+)

#### `services.collective_memory_workflow`

LangGraph Workflow for Collective Memory
Gestisce memoria collettiva intelligente (work + personal) con workflow condizionali

#### `services.communication.__init__`

Communication utilities for response formatting and analysis.

This package provides utilities for:
- Language detection and language-specific instructions
- Emotional content detection and empathetic response formatting
- Procedural question detection and step-by-step formatting
- Domain-specific formatting (Visa, Tax, Company)
- Explanation level detection (simple, standard, expert)

This module maintains backward compatibility with the original communication_utils module
by re-exporting all functions from the focused sub-modules.

Example usage:
    from services.communication import detect_language, has_emotional_content

    language = detect_language(query)
    if has_emotional_content(query):
        instruction = get_emotional_response_instruction(language)

#### `services.communication.domain_formatter`

Domain-Specific Formatting Instructions

Responsibility: Provide formatting instructions for domain-specific questions
(Visa, Tax, Company Setup) using standard templates.

Domains supported:
- visa: KITAS, work permits, visa applications
- tax: Indonesian taxation, NPWP, tax compliance
- company: PT PMA setup, business registration

#### `services.communication.emotion_analyzer`

Emotion Analysis Utilities

Responsibility: Detect emotional content in user queries and provide appropriate
response instructions for empathetic communication.

Supports detection of emotions like:
- Frustration, desperation
- Happiness, hope
- Worry, anxiety, fear
- Anger, sadness

#### `services.communication.explanation_detector`

Explanation Level Detection Service

Detects user intent for explanation level (simple/expert/standard) and alternative requests.

#### `services.communication.language_detector`

Language Detection Utilities

Responsibility: Detect language from user queries and provide language-specific instructions
for the ZANTARA persona (Garda Depan Leluhur).

Supported languages:
- Italian (it) - Primary language for Bali Zero clients
- English (en) - International clients
- Indonesian (id) - Local context
- Auto - Adaptive detection

#### `services.communication.procedural_formatter`

Procedural Question Detection and Formatting

Responsibility: Detect if user is asking for step-by-step instructions and provide
formatting guidelines for procedural responses.

Examples of procedural questions:
- "How do I apply for a visa?"
- "What are the steps to set up a company?"
- "Come faccio a ottenere un KITAS?"

#### `services.compliance.__init__`

Compliance Module
Specialized services extracted from ProactiveComplianceMonitor

#### `services.compliance.alert_generator`

Alert Generator Service
Responsibility: Generate compliance alerts

#### `services.compliance.compliance_tracker`

Compliance Tracker Service
Responsibility: Track compliance items

#### `services.compliance.notifications`

Compliance Notification Service
Responsibility: Send compliance notifications

#### `services.compliance.severity_calculator`

Severity Calculator Service
Responsibility: Calculate alert severity

#### `services.compliance.templates`

Compliance Templates Service
Responsibility: Manage compliance templates

#### `services.conflict_resolver`

Conflict Resolver Service
Detects and resolves conflicts between results from different collections

Extracted from SearchService to follow Single Responsibility Principle.

#### `services.context_window_manager`

Context Window Manager - Intelligent conversation history management
Prevents context overflow by keeping only recent messages with automatic summarization

#### `services.cross_oracle_synthesis_service`

Cross-Oracle Synthesis Agent - Phase 3 (Core Agent #1)

Orchestrates queries across multiple Oracle collections and synthesizes
integrated recommendations using ZANTARA AI.

Example Scenario: "I want to open a restaurant in Canggu"
‚Üí Queries: kbli_eye, legal_architect, tax_genius, visa_oracle, property_knowledge, bali_zero_pricing
‚Üí Synthesizes: Integrated plan with KBLI code, legal structure, tax obligations,
               staff visa requirements, location requirements, timeline, and total investment

This is the "magic" agent that makes complex business queries feel effortless.

#### `services.cultural_insights_service`

Cultural Insights Service
Manages cultural insights storage and retrieval from Qdrant

Extracted from SearchService to follow Single Responsibility Principle.

#### `services.cultural_rag_service`

Cultural RAG Service - Retrieve ZANTARA-generated Indonesian cultural intelligence

This service retrieves cultural insights from Qdrant that were generated by ZANTARA AI
and injects them as context for ZANTARA AI to provide culturally-aware responses.

Pattern: ZANTARA AI generates cultural knowledge offline ‚Üí Qdrant stores ‚Üí ZANTARA AI uses at runtime
Cost: Zero (pre-generated, instant retrieval)
Latency: <5ms (Qdrant vector search)

#### `services.deepseek_client`

DeepSeek V3 Client - Cheapest LLM API fallback

Pricing: $0.27/1M input, $1.10/1M output (December 2025)
API: OpenAI-compatible

Fallback chain: Gemini 2.0 Flash ‚Üí DeepSeek V3 ‚Üí OpenRouter (free models)

#### `services.dynamic_pricing_service`

Dynamic Scenario Pricer - Phase 3 (Core Agent #2)

Calculates comprehensive pricing for business scenarios by aggregating
costs from multiple Oracle collections.

Example: "PT PMA Restaurant in Seminyak, 3 foreign directors"
‚Üí Aggregates costs from:
  - KBLI setup (kbli_eye)
  - Legal incorporation (legal_architect)
  - Tax registration (tax_genius)
  - Visa costs (visa_oracle) x3
  - Location requirements (property_knowledge)
  - Service fees (bali_zero_pricing)

‚Üí Output: Detailed breakdown + total investment + timeline

#### `services.emotional_attunement`

ZANTARA Emotional Attunement Service - Phase 4

Detects emotional state from message content and adapts response tone/style.
Integrates with CollaboratorService for personalized emotional preferences.

#### `services.episodic_memory_service`

Episodic Memory Service - Timeline of User Events

Manages user experiences and events over time, enabling:
- "When did I start the PT PMA process?"
- "What happened last week?"
- "Show me my milestones"

Features:
- Store events with temporal context (when, what, emotion)
- Extract events automatically from conversations
- Link events to Knowledge Graph entities
- Timeline queries with filtering

#### `services.followup_service`

Follow-up Service - Generate suggested follow-up questions
Helps users continue conversations naturally by suggesting relevant next questions

This service generates 3-4 contextually relevant follow-up questions after each AI response,
improving engagement and helping users discover what they can ask next.

Author: ZANTARA Development Team
Date: 2025-10-16

#### `services.gemini_service`

Gemini Jaksel Service with OpenRouter Fallback

Primary: Google Gemini API (gemini-2.5-flash)
Fallback: OpenRouter free models when quota exceeded (429)

#### `services.golden_answer_service`

Golden Answer Service - Fast lookup of pre-generated FAQ answers

Provides sub-100ms lookup of cached answers for frequent queries.
Integrated into Sonnet workflow BEFORE RAG search.

Flow:
1. User query comes in
2. Check golden_answers table (10-20ms PostgreSQL lookup)
3. If match found ‚Üí return cached answer immediately
4. If no match ‚Üí proceed to normal RAG + Sonnet generation

This provides 250x speedup for ~50-60% of queries.

#### `services.golden_router_service`

Golden Router Service
Instrada query a documenti specifici basandosi su "Golden Routes" (query canoniche).
Usa similarit√† semantica per matchare query utente ‚Üí query canonica ‚Üí documento.

#### `services.health_monitor`

Health Monitor Service
Monitors system health and sends alerts on downtime or degradation

#### `services.image_generation_service`

Google Imagen Service for ZANTARA
Uses Google's Generative AI (Imagen) to generate images from text prompts.

#### `services.ingestion_service`

ZANTARA RAG - Ingestion Service
Book processing pipeline: parse ‚Üí chunk ‚Üí embed ‚Üí store
Auto-routes legal documents to LegalIngestionService

#### `services.journey.__init__`

Journey Module
Specialized services extracted from ClientJourneyOrchestrator

#### `services.journey.journey_builder`

Journey Builder Service
Responsibility: Build journeys from templates

#### `services.journey.journey_templates`

Journey Templates Service
Responsibility: Manage journey templates

#### `services.journey.prerequisites_checker`

Prerequisites Checker Service
Responsibility: Check step prerequisites

#### `services.journey.progress_tracker`

Progress Tracker Service
Responsibility: Track journey progress

#### `services.journey.step_manager`

Step Manager Service
Responsibility: Manage step lifecycle

#### `services.knowledge_graph_builder`

Knowledge Graph Builder - Phase 4 (Advanced Agent)

Builds and maintains a knowledge graph of relationships between entities
discovered in Qdrant collections.

Example Knowledge Graph:
```
KBLI 56101 (Restaurant)
  ‚îú‚îÄ‚Üí requires ‚Üí NIB
  ‚îú‚îÄ‚Üí requires ‚Üí NPWP
  ‚îú‚îÄ‚Üí tax_obligation ‚Üí PPh 23 (2%)
  ‚îú‚îÄ‚Üí tax_obligation ‚Üí PPn (11%)
  ‚îú‚îÄ‚Üí legal_structure ‚Üí PT vs CV
  ‚îú‚îÄ‚Üí location_restriction ‚Üí Zoning rules
  ‚îî‚îÄ‚Üí staff_visa ‚Üí IMTA requirements

PT PMA
  ‚îú‚îÄ‚Üí requires ‚Üí Min Investment (Rp 10B)
  ‚îú‚îÄ‚Üí requires ‚Üí Foreign Director (min 1)
  ‚îú‚îÄ‚Üí process_time ‚Üí 60-90 days
  ‚îú‚îÄ‚Üí registration_at ‚Üí BKPM
  ‚îî‚îÄ‚Üí related_to ‚Üí KBLI codes

KITAS (Limited Stay Permit)
  ‚îú‚îÄ‚Üí requires ‚Üí Sponsor Company
  ‚îú‚îÄ‚Üí requires ‚Üí IMTA
  ‚îú‚îÄ‚Üí validity ‚Üí 1 year (renewable)
  ‚îú‚îÄ‚Üí cost ‚Üí Rp 5-15 million
  ‚îî‚îÄ‚Üí related_to ‚Üí Work Permit
```

The graph is stored in JSON/dict format (could be migrated to Neo4j later).

#### `services.legal_ingestion_service`

Legal Ingestion Service
Specialized ingestion pipeline for Indonesian legal documents

#### `services.mcp_client_service`

MCP Client Service - Connette Nuzantara a MCP Servers esterni
Permette all'AI di usare tool MCP (brave-search, filesystem, etc.)

#### `services.memory.__init__`

Memory Module - Centralized Memory Orchestration for ZANTARA

This module provides a unified interface for all memory operations:
- Fact extraction from conversations
- Persistent storage in PostgreSQL
- Semantic search in Qdrant (future)
- Cross-session memory retrieval

Architecture:
    MemoryOrchestrator (facade)
        ‚îú‚îÄ‚îÄ MemoryFactExtractor (extraction)
        ‚îú‚îÄ‚îÄ MemoryServicePostgres (PostgreSQL storage)
        ‚îî‚îÄ‚îÄ MemoryVectorService (Qdrant search - future)

Usage:
    from services.memory import MemoryOrchestrator

    orchestrator = MemoryOrchestrator(db_pool)
    await orchestrator.initialize()

    # Get user context before query
    context = await orchestrator.get_user_context(user_email)

    # Save facts after query
    await orchestrator.process_conversation(
        user_email=user_email,
        user_message=query,
        ai_response=response,
    )

#### `services.memory.models`

Memory Module Models - Pydantic models for memory operations

These models provide a unified interface for all memory operations,
replacing the scattered dataclasses and dicts used across services.

#### `services.memory.orchestrator`

Memory Orchestrator - Centralized Memory Management for ZANTARA

This is the main entry point for all memory operations. It coordinates:
- MemoryServicePostgres: PostgreSQL persistence for facts and stats
- MemoryFactExtractor: Pattern-based fact extraction from conversations
- (Future) MemoryVectorService: Qdrant semantic search

Usage:
    orchestrator = MemoryOrchestrator(db_pool)
    await orchestrator.initialize()

    # Get user context before generating response
    context = await orchestrator.get_user_context(user_email)

    # Save facts after response is generated
    result = await orchestrator.process_conversation(
        user_email=user_email,
        user_message=query,
        ai_response=response,
    )

#### `services.memory_fact_extractor`

Memory Fact Extractor - Automatic key facts extraction from conversations
Extracts important facts to save in user memory for context building

#### `services.memory_service_postgres`

ZANTARA Memory Service - PostgreSQL Backend (Fly.io)

Manages user memory (profile facts, conversation summary, counters) with PostgreSQL persistence.
Replaces Firestore with PostgreSQL for Fly.io deployment.

#### `services.migration_runner`

NUZANTARA PRIME - Automatic Migration Runner

Provides automatic migration execution with versioning and dependency management.
Replaces manual apply_migration_XXX.py scripts.

Features:
- Automatic discovery of migrations
- Dependency resolution
- Version tracking
- Rollback support
- Dry-run mode

#### `services.multimodal.pdf_vision_service`

PDF Vision Service
Usa Gemini Vision per "vedere" e interpretare tabelle complesse nei PDF (es: KBLI).
Integrato con Google Drive per scaricare i file on-demand.

#### `services.openrouter_client`

OpenRouter Smart AI Client - Native Fallback System

Uses OpenRouter's native 'models' array for server-side fallback (more efficient).
With $10+ credits: 1000 req/day on free models.

Free Models Available (as of 2025):
- google/gemini-2.0-flash-exp:free (1M context, best for RAG)
- meta-llama/llama-3.3-70b-instruct:free (131K context, best reasoning)
- qwen/qwen3-235b-a22b:free (40K context, powerful)
- mistralai/mistral-small-3.1-24b-instruct:free (32K context, fast)
- meta-llama/llama-3.2-3b-instruct:free (131K context, fastest)

Best Practice: Use 'models' array for automatic server-side fallback.
OpenRouter tries models in order until one succeeds.

#### `services.oracle.__init__`

Oracle Module
Specialized services extracted from OracleService

#### `services.oracle.analytics`

Oracle Analytics Service
Responsibility: Query analytics and tracking

#### `services.oracle.document_retrieval`

Document Retrieval Service
Responsibility: PDF download and document handling from Google Drive

#### `services.oracle.language_detector`

Language Detection Service
Responsibility: Detect query language for localization

#### `services.oracle.reasoning_engine`

Reasoning Engine Service
Responsibility: Gemini reasoning logic for query processing

#### `services.oracle.user_context`

User Context Service
Responsibility: Manage user profile, memory, and personality context

#### `services.oracle_config`

Oracle Configuration Service
Manages configuration for Oracle Universal endpoints

#### `services.oracle_database`

Oracle Database Service
Manages PostgreSQL database operations for Oracle endpoints

#### `services.oracle_google_services`

Oracle Google Services
Manages Google Gemini AI and Drive integration for Oracle endpoints

#### `services.oracle_service`

Oracle Service
==============
Core business logic for the Universal Oracle system.
Decoupled from FastAPI router for better testability and maintainability.

REFACTORED: Uses sub-services following Single Responsibility Principle
- LanguageDetectionService: Language detection
- UserContextService: User profile/memory/personality
- ReasoningEngineService: Gemini reasoning
- DocumentRetrievalService: PDF/Drive integration
- OracleAnalyticsService: Analytics tracking

#### `services.performance_optimizer`

Performance Optimization Enhancements
For ZANTARA RAG Backend Python

#### `services.personality_service`

ZANTARA Multi-Personality Service

Gestisce le diverse personalit√† dell'AI system:
- Jaksel: Indonesian slang (Amanda, Anton, Krisna, Dea, etc.)
- ZERO: Italian style (Zero, Nina)
- Professional: Standard English/Indonesian
- Custom: Basato sulle preferenze del team member

Integra Gemini 1.5 (RAG research) + Zantara Oracle Cloud (personality voice)

#### `services.pricing_service`

Bali Zero Official Pricing Service
Loads official prices from JSON (NO AI GENERATION)

#### `services.proactive_compliance_monitor`

Proactive Compliance Monitor - Phase 3 (Orchestration Agent #2)

Monitors compliance deadlines and requirements for clients, sending
proactive alerts before deadlines.

Features:
- Tracks visa expiry dates (KITAS, KITAP, passport)
- Monitors tax filing deadlines (SPT Tahunan, PPh, PPn)
- Tracks license renewals (IMTA, NIB, business permits)
- Monitors regulatory changes from legal_updates/tax_updates
- Sends proactive notifications (60/30/7 days before)
- Auto-calculates renewal costs from bali_zero_pricing

REFACTORED: Uses sub-services following Single Responsibility Principle
- ComplianceTrackerService: Item tracking
- AlertGeneratorService: Alert generation
- SeverityCalculatorService: Severity calculation
- ComplianceTemplatesService: Template management
- ComplianceNotificationService: Notification sending

Example Monitored Items:
- KITAS expiry: Remind 60 days before
- SPT Tahunan deadline (March 31): Remind in February
- IMTA renewal: Remind 30 days before
- Regulation changes: Immediate alert if affects client

#### `services.query_router`

ZANTARA RAG - Query Router
Intelligent routing between multiple Qdrant collections based on query content

Phase 3 Enhancement: Smart Fallback Chain Agent
- Confidence scoring for routing decisions
- Automatic fallback to secondary collections when confidence is low
- Configurable fallback chains per domain
- Detailed logging and metrics

REFACTORED: Uses sub-services following Single Responsibility Principle
- KeywordMatcherService: Keyword matching
- ConfidenceCalculatorService: Confidence calculation
- FallbackManagerService: Fallback chain management
- PriorityOverrideService: Priority override detection
- RoutingStatsService: Statistics tracking

#### `services.query_router_integration`

Query Router Integration Service
Handles query routing and collection selection logic

Extracted from SearchService to follow Single Responsibility Principle.

#### `services.rag.agent.diagnostics_tool`

Diagnostics Tool - System Health & Status Check
Permette a Zantara di diagnosticare lo stato dei servizi backend (DB, Redis, Qdrant).

#### `services.rag.agent.mcp_tool`

MCP Super Tool - D√† a Zantara i superpoteri MCP
Solo per admin (zero@balizero.com)

Permette a Zantara di:
- Cercare sul web in tempo reale (Brave Search)
- Leggere/scrivere file
- Salvare memoria persistente
- Ragionamento step-by-step

#### `services.rag.agentic.__init__`

Agentic RAG with Tool Use - Refactored Architecture

This module has been refactored from a 2,200+ line monolithic file into
a well-structured package with clear separation of concerns:

Structure:
- tools.py: Tool class definitions (VectorSearch, WebSearch, Database, Calculator, Vision, Pricing)
- orchestrator.py: Main orchestrator with query processing and streaming (910 lines)
- llm_gateway.py: Unified LLM interface with model fallback cascade (493 lines)
- reasoning.py: ReAct reasoning loop (Thought‚ÜíAction‚ÜíObservation) (294 lines)
- prompt_builder.py: System prompt construction with caching
- response_processor.py: Response cleaning and formatting
- context_manager.py: User context and memory management
- tool_executor.py: Tool parsing and execution with rate limiting
- pipeline.py: Response processing pipeline with verification, cleaning, and citation stages

Key Features:
- Quality routing (Fast/Pro/DeepThink)
- ReAct pattern (Reason-Act-Observe)
- Multi-tier fallback (Gemini Pro -> Flash -> Flash-Lite -> OpenRouter)
- Native function calling with regex fallback
- Memory persistence and semantic caching
- Streaming and non-streaming modes
- Response verification and self-correction

Backward Compatibility:
All original exports are maintained for seamless integration with existing code.

#### `services.rag.agentic.context_manager`

User Context Management for Agentic RAG

This module handles retrieval and management of user context including:
- User profile data from team_members table
- Conversation history
- Memory facts (via MemoryOrchestrator)
- Collective knowledge facts
- Memory vector search for recall assist

Key Features:
- Optimized single-query profile + history fetch (eliminates N+1 pattern)
- Integration with MemoryOrchestrator as single source of truth
- Memory cache fallback for entity extraction
- Graceful degradation on failures

#### `services.rag.agentic.llm_gateway`

LLM Gateway - Unified interface for LLM interactions with automatic fallback.

This module provides a centralized gateway for all Language Model interactions,
handling model initialization, tier-based routing, and automatic fallback cascades.

Key Features:
- Multi-tier Gemini model support (Pro, Flash, Flash-Lite)
- Automatic fallback cascade on quota/service errors
- OpenRouter integration as final fallback
- Native function calling support
- Error handling and retry logic
- Health check capabilities

Architecture:
    LLMGateway acts as the single source of truth for all LLM operations,
    abstracting model complexity from business logic. It ensures high
    availability through intelligent fallback routing.

Example:
    >>> gateway = LLMGateway(gemini_tools=[...])
    >>> response, model, obj = await gateway.send_message(
    ...     chat=chat_session,
    ...     message="What is KITAS?",
    ...     tier=TIER_FLASH,
    ... )
    >>> print(f"Response from {model}: {response}")

Author: Nuzantara Team
Date: 2025-12-17
Version: 1.0.0

#### `services.rag.agentic.orchestrator`

Agentic RAG Orchestrator - Main Query Processing Logic

This is the core orchestrator that coordinates all agentic RAG operations:
- Query routing (Fast/Pro/DeepThink)
- Tool-based reasoning (ReAct pattern)
- Streaming and non-streaming query processing
- Model fallback cascade (Gemini Pro -> Flash -> Flash-Lite -> OpenRouter)
- Memory persistence
- Semantic caching
- Response verification

Architecture:
- Uses modular components for context, prompts, tools, and processing
- Implements quality routing based on intent classification
- Supports conversation history with context window management
- Provides backward compatibility with legacy interfaces

#### `services.rag.agentic.pipeline`

Response Processing Pipeline

A clean pipeline pattern for processing LLM responses through multiple stages.
Each stage is independent and can be tested/configured separately.

Architecture:
- PipelineStage: Base class for all processing stages
- VerificationStage: Verify response quality and accuracy
- PostProcessingStage: Clean and format response text
- CitationStage: Extract and normalize citations
- FormatStage: Final formatting for output
- ResponsePipeline: Main orchestrator that runs data through stages

Benefits:
- Single Responsibility: Each stage has one job
- Testability: Test stages independently
- Reusability: Stages can be reused in different pipelines
- Configurability: Easy to add/remove stages
- No Duplication: Post-processing logic in one place

#### `services.rag.agentic.prompt_builder`

System Prompt Builder for Agentic RAG

This module handles construction of dynamic system prompts based on:
- User profile and identity
- Personal memory facts
- Collective knowledge
- Query characteristics (language, domain, format)
- Deep think mode activation

Key Features:
- Caching system with 5-minute TTL
- Cache key includes facts count for invalidation
- Dynamic language/format instructions
- Domain-specific formatting (visa, tax, company)
- Explanation level detection

#### `services.rag.agentic.reasoning`

ReAct Reasoning Engine - Thought ‚Üí Action ‚Üí Observation Loop

This component handles the core agentic reasoning loop using the ReAct pattern:
- Thought: LLM generates reasoning about what to do next
- Action: Execute a tool based on the thought
- Observation: Collect results from tool execution
- Repeat until final answer or max steps reached

Key features:
- Native function calling with regex fallback
- Early exit optimization for efficient queries
- Citation handling for vector search results
- Final answer generation if not provided
- Integration with response verification pipeline

#### `services.rag.agentic.response_processor`

Response Post-Processing for Agentic RAG

This module handles cleaning and formatting of AI responses:
- Clean internal reasoning patterns (THOUGHT:, ACTION:, Observation:)
- Enforce language detection
- Format procedural questions as numbered lists
- Add emotional acknowledgment when needed
- Verify responses against source context

Key Features:
- Integration with response cleaner service
- Communication rules enforcement
- Emotional attunement
- Format detection and transformation

#### `services.rag.agentic.tool_executor`

Tool Execution and Parsing for Agentic RAG

This module handles:
- Parsing tool calls from AI responses (native function calling or ReAct format)
- Executing tools with rate limiting
- Tool result handling
- Security validation

Key Features:
- Native Gemini function calling (primary)
- Regex ReAct parser fallback for OpenRouter/non-Gemini models
- Rate limiting (max 10 executions per query)
- User ID injection for admin tools
- Error handling and logging

#### `services.rag.agentic.tools`

Agentic RAG Tool Definitions

This module contains all tool class definitions used by the AgenticRAGOrchestrator.
Each tool inherits from BaseTool and implements the required interface:
- name: unique tool identifier
- description: what the tool does
- parameters_schema: JSON schema for tool arguments
- execute(): async method that performs the tool's action

Tools included:
- VectorSearchTool: Knowledge base search with collection routing
- WebSearchTool: Web search (fallback/disabled by default)
- DatabaseQueryTool: Direct database queries for deep dive
- CalculatorTool: Safe mathematical calculations
- VisionTool: Visual document analysis
- PricingTool: Official Bali Zero pricing lookup

#### `services.rag.verification_service`

Verification Service
Implements the "Draft -> Verify" pattern for Agentic RAG.
Acts as a judge to evaluate if the generated answer is supported by the retrieved context.

#### `services.rag.vision_rag`

Vision RAG Service
RAG multi-modale per documenti con immagini, tabelle, grafici.

#### `services.response.standard_templates`

Standard Response Templates for ZANTARA
Defines structured markdown formats for key business domains (Visa, Tax, etc.)
to ensure consistency and readability.

#### `services.routing.__init__`

Routing Module
Specialized routing services extracted from QueryRouter

#### `services.routing.confidence_calculator`

Confidence Calculator Service
Responsibility: Calculate confidence scores for routing decisions

#### `services.routing.fallback_manager`

Fallback Manager Service
Responsibility: Manage fallback chains and collection selection

#### `services.routing.keyword_matcher`

Keyword Matcher Service
Responsibility: Match keywords to domains for query routing

#### `services.routing.priority_override`

Priority Override Service
Responsibility: Detect priority override patterns (identity, team, backend services)

#### `services.routing.response_handler`

Response Handler Module
Applies response sanitization and quality enforcement

#### `services.routing.routing_stats`

Routing Statistics Service
Responsibility: Track routing statistics and metrics

#### `services.routing.specialized_service_router`

Specialized Service Router Module
Routes to autonomous research and cross-oracle synthesis services

#### `services.search_service`

ZANTARA RAG - Search Service
Core search functionality with tier-based access control

REFACTORED: Split into focused services following Single Responsibility Principle.
- Collection management ‚Üí CollectionManager
- Conflict resolution ‚Üí ConflictResolver
- Cultural insights ‚Üí CulturalInsightsService
- Query routing ‚Üí QueryRouterIntegration
- Health monitoring ‚Üí CollectionHealthService
- Collection warmup ‚Üí CollectionWarmupService

This service now handles ONLY core search logic with proper delegation.

#### `services.semantic_cache`

Semantic Cache Service for RAG System

Features:
- Cache query embeddings (avoid re-computing)
- Cache RAG search results
- Similarity-based cache lookup (cosine similarity)
- TTL-based expiration
- LRU eviction policy

Performance Impact:
- Latency: 800ms ‚Üí 150ms (-81%)
- API costs: -50% (fewer embeddings)
- Database load: -70% (fewer Qdrant queries)

#### `services.session_service`

Session Service - Redis-based conversation history storage for ZANTARA

Eliminates URL length constraints by storing conversation history in Redis
and passing only session_id in requests. Supports 50+ message conversations.

Author: ZANTARA AI Code (Bali Zero Team)
Date: November 5, 2025

#### `services.smart_oracle`

Zantara Smart Oracle - Enhanced PDF Analysis with Google Drive Integration

This module provides intelligent document analysis by:
1. Downloading PDFs from Google Drive using Service Account
2. Processing documents with Google Gemini AI
3. Providing accurate answers based on full document content

#### `services.team_analytics_service`

Team Work Analytics Service
7 Advanced Techniques for Team Performance Analysis

Provides intelligent insights on:
1. Pattern Recognition - Work hour patterns and habits
2. Productivity Scoring - Session productivity metrics
3. Burnout Detection - Early warning signs
4. Performance Trends - Long-term performance analysis
5. Workload Balance - Team workload distribution
6. Optimal Hours - Best performance time windows
7. Team Insights - Collaboration and synergy analysis

REFACTORED: Uses sub-services following Single Responsibility Principle
- PatternAnalyzerService: Work pattern analysis
- ProductivityScorerService: Productivity scoring
- BurnoutDetectorService: Burnout detection
- PerformanceTrendService: Trend analysis
- WorkloadBalanceService: Workload analysis
- OptimalHoursService: Optimal hours identification
- TeamInsightsService: Team insights generation

#### `services.team_timesheet_service`

Team Timesheet Service
Manages team member work hours tracking (clock-in/clock-out)
Timezone: Asia/Makassar (Bali Time, UTC+8)

#### `services.tool_executor`

TOOL EXECUTOR SERVICE
Handles ZANTARA AI tool use execution
All tools are Python-native (ZantaraTools, GmailService, CalendarService, etc.)
+ MCP Client tools (filesystem, memory, brave-search, etc.)

#### `services.tools.__init__`

Tools Module
Tool loading, caching, and detection

#### `services.unified_health_service`

NUZANTARA PRIME - Unified Health Check Service

Centralizes all health check functionality:
- Manual health checks (from scripts/health_check.py)
- Continuous monitoring (from self_healing/backend_agent.py)
- Service registry integration (from app.core.service_health)

This service provides a single source of truth for system health.

#### `services.vertex_ai_service`

Vertex AI Service
Handles interactions with Google Cloud Vertex AI (Gemini Pro).
Used as a fallback for complex extraction tasks.

#### `services.work_session_service`

Work Session Tracking Service
Tracks team member work hours and activities
All reports sent to ZERO only

#### `services.zantara_tools`

ZANTARA Tools - Python Native Tools for ZANTARA AI
Direct execution (no HTTP calls) - faster & more reliable

### Utils

#### `utils.__init__`

ZANTARA RAG - Utilities

#### `utils.response_sanitizer`

Response Sanitization Utilities for ZANTARA
Fixes Phase 1 & 2: Remove training data artifacts and enforce quality standards

#### `utils.tier_classifier`

ZANTARA RAG - Tier Classification
Classify books into knowledge tiers (S, A, B, C, D)

## Services

### `AlertGeneratorService`

**Module:** `services.compliance.alert_generator`

Service for generating compliance alerts.

Responsibility: Generate alerts from compliance items.

### `AlertService`

**Module:** `services.alert_service`

Service for sending alerts to various channels

### `AuditService`

**Module:** `services.audit_service`

Service for logging security and system events to the database.

### `AutoCRMService`

**Module:** `services.auto_crm_service`

Automatically populate CRM from conversations using AI extraction

Uses centralized asyncpg connection pool via dependency injection.
No longer creates its own pool - uses app.state.db_pool.

### `AutonomousResearchService`

**Module:** `services.autonomous_research_service`

Autonomous research agent that explores Qdrant collections iteratively.

The agent:
1. Starts with initial query
2. Searches most relevant collection
3. Analyzes results for gaps
4. Expands query based on findings
5. Searches additional collections
6. Repeats until confident or max iterations
7. Synthesizes findings into final answer using ZANTARA AI

### `BurnoutDetectorService`

**Module:** `services.analytics.burnout_detector`

Service for detecting burnout signals.

Responsibility: Detect early warning signs of burnout.

### `CacheService`

**Module:** `core.cache`

Intelligent caching service with Redis backend
Falls back to in-memory cache if Redis unavailable

Uses dependency injection instead of global state.
Each instance has its own in-memory cache (instance-level, not module-level).

Usage with DI:
    from fastapi import Depends
    from core.cache import get_cache_service

    async def endpoint(cache: CacheService = Depends(get_cache_service)):
        value = cache.get("key")

### `CitationService`

**Module:** `services.citation_service`

Manages citation formatting and source references for AI responses

Features:
- Inline citation markers [1], [2], etc.
- Full source details with titles, URLs, dates
- Automatic citation numbering
- Support for multiple source types (RAG docs, memory, web)

### `ClarificationService`

**Module:** `services.clarification_service`

Detects ambiguous queries and generates clarification requests

Features:
- Pattern-based ambiguity detection
- Context-aware clarification questions
- Multi-language support (EN, IT, ID)
- Confidence scoring for ambiguity detection

### `ClientScoringService`

**Module:** `agents.services.client_scoring`

Service for calculating client LTV scores

### `ClientSegmentationService`

**Module:** `agents.services.client_segmentation`

Service for segmenting clients and calculating risk levels

### `CollaboratorService`

**Module:** `services.collaborator_service`

Load collaborator profiles from JSON and expose search utilities.

Compatible with the old API (TEAM_DATABASE, identify) so existing plugins/tools
continue to work.

### `CollectionHealthService`

**Module:** `services.collection_health_service`

Monitors and reports on Qdrant collection health.

Tracks:
- Collection usage patterns
- Data freshness
- Query performance
- Quality metrics

Provides:
- Health scores per collection
- Staleness alerts
- Actionable recommendations
- Admin dashboard data

### `CollectionWarmupService`

**Module:** `services.collection_warmup_service`

Service for warming up Qdrant collections on startup.

Responsibilities:
- Pre-load critical collections into memory
- Initialize embedding models
- Reduce first-query latency from 5-20s to <1s

Does NOT handle:
- Search operations (use SearchService)
- Collection management (use CollectionManager)

### `CollectiveMemoryService`

**Module:** `services.collective_memory_service`

Service for managing collective memory - shared knowledge across users.

Workflow:
1. User contributes a fact ‚Üí stored with source tracking
2. Other users confirm same fact ‚Üí source_count increases
3. When source_count >= 3 ‚Üí fact becomes "promoted" (collective)
4. Promoted facts are included in AI context for all users

### `ComplianceNotificationService`

**Module:** `services.compliance.notifications`

Service for sending compliance notifications.

Responsibility: Send alerts via various channels (WhatsApp, Email, etc.).

### `ComplianceTemplatesService`

**Module:** `services.compliance.templates`

Service for managing compliance templates.

Responsibility: Provide compliance templates and annual deadlines.

### `ComplianceTrackerService`

**Module:** `services.compliance.compliance_tracker`

Service for tracking compliance items.

Responsibility: Add, retrieve, and manage compliance items.

### `ConfidenceCalculatorService`

**Module:** `services.routing.confidence_calculator`

Service for calculating routing confidence scores.

Responsibility: Calculate confidence based on match strength, query length, and domain specificity.

### `ConversationService`

**Module:** `services.conversation_service`

Service for managing conversation persistence and retrieval.
Handles saving to PostgreSQL, Memory Cache fallback, and triggering Auto-CRM.

### `CrossOracleSynthesisService`

**Module:** `services.cross_oracle_synthesis_service`

Orchestrates multi-Oracle queries and synthesizes integrated responses.

The "conductor" of the Oracle system - knows when to consult which Oracles
and how to combine their knowledge into actionable business plans.

### `CulturalInsightsService`

**Module:** `services.cultural_insights_service`

Manages cultural insights storage and retrieval.

REFACTORED: Extracted from SearchService to reduce complexity.

Responsibilities:
- Add cultural insights to Qdrant
- Query cultural insights by semantic search
- Format cultural insights for prompt injection

Does NOT handle:
- General document search (use SearchService)
- Collection management (use CollectionManager)

### `CulturalRAGService`

**Module:** `services.cultural_rag_service`

Retrieves ZANTARA-generated Indonesian cultural intelligence for ZANTARA AI enrichment

### `DocumentRetrievalService`

**Module:** `services.oracle.document_retrieval`

Service for document retrieval from Google Drive.

Responsibility: Download PDFs from Google Drive using fuzzy search.

### `DynamicPricingService`

**Module:** `services.dynamic_pricing_service`

Calculates scenario-based pricing by aggregating Oracle knowledge.

Works with CrossOracleSynthesisService to extract cost information.

### `EmotionalAttunementService`

**Module:** `services.emotional_attunement`

Analyzes message content to detect emotional state and suggest appropriate tone.

Features:
- Pattern-based emotion detection
- Keyword analysis
- Punctuation and capitalization analysis
- Integration with collaborator preferences
- Tone adaptation suggestions

### `EpisodicMemoryService`

**Module:** `services.episodic_memory_service`

Service for managing episodic memories (timeline of events)

### `FallbackManagerService`

**Module:** `services.routing.fallback_manager`

Service for managing fallback chains.

Responsibility: Determine which collections to query based on confidence and fallback chains.

### `FollowupService`

**Module:** `services.followup_service`

Generates suggested follow-up questions based on conversation context

Features:
- Context-aware question generation
- Language-appropriate suggestions (EN, IT, ID)
- Topic-specific follow-ups (business, casual, technical)
- Fast generation using ZANTARA AI

### `GeminiService`

**Module:** `services.gemini_service`

Wrapper class for GeminiJakselService to maintain compatibility with tests.

### `GoldenAnswerService`

**Module:** `services.golden_answer_service`

Fast lookup and retrieval of pre-generated golden answers

### `GoldenRouterService`

**Module:** `services.golden_router_service`

Router intelligente che mappa query utente a documenti specifici.
Non √® una cache di risposte, ma una cache di "intenti di routing".

### `GoogleServices`

**Module:** `services.oracle_google_services`

Google Cloud services manager for Oracle endpoints

### `IdentityService`

**Module:** `app.modules.identity.service`

Identity Service - Authentication and user management

Replicates the exact login flow from Node.js backend (team-login.ts)

### `ImageGenerationService`

**Module:** `services.image_generation_service`

Service to generate images using Google's Generative AI.

### `IngestionService`

**Module:** `services.ingestion_service`

Complete book ingestion pipeline.
Handles the full flow from raw document to searchable embeddings.

### `JourneyBuilderService`

**Module:** `services.journey.journey_builder`

Service for building client journeys.

Responsibility: Create journeys from templates or custom steps.

### `JourneyTemplatesService`

**Module:** `services.journey.journey_templates`

Service for managing journey templates.

Responsibility: Provide predefined journey templates for common scenarios.

### `KeywordMatcherService`

**Module:** `services.routing.keyword_matcher`

Service for matching keywords to domains.

Responsibility: Calculate domain scores based on keyword matching.

### `KnowledgeService`

**Module:** `app.modules.knowledge.service`

Knowledge Service - RAG search with access control and multi-collection support

This service encapsulates all RAG/search logic, separated from HTTP interface.

### `LanguageDetectionService`

**Module:** `services.oracle.language_detector`

Service for detecting query language.

Responsibility: Detect language from query text with Italian focus for Bali Zero clients.

### `LegalIngestionService`

**Module:** `services.legal_ingestion_service`

Specialized ingestion service for Indonesian legal documents.
Implements 4-stage pipeline: Clean ‚Üí Extract Metadata ‚Üí Parse Structure ‚Üí Chunk

### `MCPClientService`

**Module:** `services.mcp_client_service`

Client MCP per Nuzantara.
Connette l'AI a server MCP esterni per estendere le capacit√†.

### `MemoryServicePostgres`

**Module:** `services.memory_service_postgres`

Service for managing persistent user memory with PostgreSQL.

Features:
- Profile facts (max 10, auto-deduplicated)
- Conversation summary (max 500 chars)
- Activity counters
- PostgreSQL persistence with in-memory fallback

### `NurturingMessageService`

**Module:** `agents.services.nurturing_message`

Service for generating personalized nurturing messages

### `OptimalHoursService`

**Module:** `services.analytics.optimal_hours`

Service for identifying optimal hours.

Responsibility: Identify most productive time windows.

### `OptimizedSearchService`

**Module:** `services.performance_optimizer`

Performance-optimized search service

### `OracleAnalyticsService`

**Module:** `services.oracle.analytics`

Service for Oracle query analytics.

Responsibility: Track query analytics and store metrics.

### `PDFVisionService`

**Module:** `services.multimodal.pdf_vision_service`

Servizio per analisi multimodale di PDF.
Estrae immagini delle pagine e le invia a Gemini Pro Vision.
Supporta download da Google Drive.

### `PatternAnalyzerService`

**Module:** `services.analytics.pattern_analyzer`

Service for analyzing work patterns.

Responsibility: Analyze work hour patterns and habits.

### `PerformanceTrendService`

**Module:** `services.analytics.performance_trend`

Service for analyzing performance trends.

Responsibility: Analyze performance trends over time.

### `PersonalityService`

**Module:** `services.personality_service`

Servizio che gestisce le diverse personalit√† di ZANTARA
basandosi sul team member che interagisce

### `PoliticsIngestionService`

**Module:** `services.politics_ingestion`

Ingest structured Indonesian politics KB (1999‚Üítoday) into Qdrant.
Stores in collection 'politics_id'.

### `PrerequisitesCheckerService`

**Module:** `services.journey.prerequisites_checker`

Service for checking step prerequisites.

Responsibility: Verify if prerequisites for a step are met.

### `PricingService`

**Module:** `services.pricing_service`

Official Bali Zero pricing - NO AI GENERATION ALLOWED

### `PriorityOverrideService`

**Module:** `services.routing.priority_override`

Service for detecting priority override patterns.

Responsibility: Check for special query patterns that override normal routing.

### `ProductivityScorerService`

**Module:** `services.analytics.productivity_scorer`

Service for calculating productivity scores.

Responsibility: Calculate productivity score for each team member.

### `ProgressTrackerService`

**Module:** `services.journey.progress_tracker`

Service for tracking journey progress.

Responsibility: Calculate progress metrics and identify next steps.

### `ReasoningEngineService`

**Module:** `services.oracle.reasoning_engine`

Service for Gemini reasoning.

Responsibility: Handle Gemini AI reasoning with context building and response validation.

### `RoutingStatsService`

**Module:** `services.routing.routing_stats`

Service for tracking routing statistics.

Responsibility: Record routing metrics and provide statistics.

### `SearchService`

**Module:** `services.search_service`

Core search service for document retrieval.

REFACTORED: Now handles ONLY core search functionality with proper delegation.
Uses dependency injection for all other responsibilities.

Responsibilities:
- Search documents in collections
- Apply tier-based access control
- Format search results
- Coordinate search operations

Properly delegates to:
- CollectionManager: Collection access and management
- ConflictResolver: Multi-collection conflict detection and resolution
- CollectionHealthService: Query metrics and health monitoring
- CulturalInsightsService: Cultural context enrichment
- QueryRouterIntegration: Collection routing decisions
- CollectionWarmupService: Collection pre-loading and warmup

### `ServiceHealth`

**Module:** `app.core.service_health`

Health information for a single service.

### `ServiceRegistry`

**Module:** `app.core.service_health`

Registry for tracking service health status.

Provides:
- Service registration with health status
- Overall system health assessment
- Critical service failure detection
- Health reporting for monitoring endpoints

### `ServiceStatus`

**Module:** `app.core.service_health`

Service health status levels.

### `SessionService`

**Module:** `services.session_service`

Manages conversation sessions in Redis for extended context support.

Features:
- Create/Read/Update/Delete sessions
- 24-hour TTL with auto-extension on activity
- JSON serialization of conversation history
- Automatic cleanup of expired sessions

### `SeverityCalculatorService`

**Module:** `services.compliance.severity_calculator`

Service for calculating alert severity.

Responsibility: Calculate alert severity based on days until deadline.

### `SpecializedServiceRouter`

**Module:** `services.routing.specialized_service_router`

Router for specialized services

Routes complex queries to:
- AutonomousResearchService: Ambiguous/complex multi-collection queries
- CrossOracleSynthesisService: Business planning and comprehensive queries
- ClientJourneyOrchestrator: Multi-step business workflows

### `StepManagerService`

**Module:** `services.journey.step_manager`

Service for managing step lifecycle.

Responsibility: Start, complete, and block steps.

### `TeamAnalyticsService`

**Module:** `services.team_analytics_service`

Advanced analytics for team work sessions
Provides 7 intelligent analysis techniques

REFACTORED: Delegates to specialized sub-services.

### `TeamInsightsService`

**Module:** `services.analytics.team_insights`

Service for generating team insights.

Responsibility: Generate comprehensive team collaboration insights.

### `TeamTimesheetService`

**Module:** `services.team_timesheet_service`

Team work hours tracking service

Features:
- Clock in/out tracking
- Auto-logout at 18:30 Bali time
- Daily/weekly/monthly summaries
- Real-time online status
- Admin-only dashboard data

### `UnifiedHealthService`

**Module:** `services.unified_health_service`

Unified Health Check Service

Provides:
- Comprehensive health checks for all services
- System metrics monitoring
- Integration with ServiceRegistry
- Continuous monitoring capabilities
- Health check reporting

### `UserContextService`

**Module:** `services.oracle.user_context`

Service for managing user context.

Responsibility: Load and manage user profile, memory, and personality information.

### `VerificationService`

**Module:** `services.rag.verification_service`

Service responsible for verifying RAG generated responses against source context.
Uses a lightweight LLM call to act as a 'Guardian'.

### `VertexAIService`

**Module:** `services.vertex_ai_service`

Service for interacting with Vertex AI Gemini models.

### `VisionRAGService`

**Module:** `services.rag.vision_rag`

Servizio per RAG su documenti multi-modali.
Estrae e indicizza elementi visuali (tabelle, grafici, form).

### `WhatsAppNotificationService`

**Module:** `agents.services.whatsapp_notification`

Service for sending WhatsApp messages via Twilio

### `WorkSessionService`

**Module:** `services.work_session_service`

Track team work sessions and send reports to ZERO
ZERO decides what to share with team

Data persistence:
- PostgreSQL: Primary storage (Fly.io cloud database)
- JSONL file: Local backup log (work_sessions_log.jsonl)

### `WorkloadBalanceService`

**Module:** `services.analytics.workload_balance`

Service for analyzing workload balance.

Responsibility: Analyze workload distribution across team.

## Agents

### `app/routers/agents.py`

ZANTARA Agentic Functions Router
Exposes all 10 advanced agentic capabilities as REST API endpoints

Phase 1-2: Foundation Agents (6)
Phase 3: Orchestration Agents (2)
Phase 4: Advanced Intelligence (1)
Phase 5: Automation (1)

Performance Optimizations:
- Redis caching (5 min TTL for status endpoints)
- Rate limiting (prevents abuse)
- Request deduplication

SECURITY: All endpoints require authentication (added 2025-12-03)

### `app/routers/agentic_rag.py`

Agentic RAG API Router

### `app/routers/autonomous_agents.py`

TIER 1 AUTONOMOUS AGENTS - HTTP Endpoints
Provides HTTP API for orchestrator to trigger autonomous agents

Agents:
1. Conversation Quality Trainer
2. Client LTV Predictor & Nurturing
3. Knowledge Graph Builder

### `self_healing/backend_agent.py`

ü§ñ ZANTARA Backend Self-Healing Agent

Autonomous agent that monitors backend service health and auto-fixes issues
Runs continuously on each Fly.io service (RAG, Memory, etc.)

Features:
- Health checks (API, DB, Redis, Qdrant)
- Auto-restart on failures
- Memory leak detection
- Database connection pool management
- API endpoint monitoring
- Reports to Central Orchestrator

### `services/context/agentic_orchestrator_v2.py`

---

*Last updated: 2025-12-17 12:23:50*